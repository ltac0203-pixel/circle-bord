# チケット P2-001: JWT認証ミドルウェア実装

## 📋 概要
JSON Web Token (JWT)を使用した認証ミドルウェアを実装し、APIエンドポイントを保護する。

## 🎯 目標
- JWT生成・検証機能の実装
- 認証ミドルウェアの作成
- トークン有効期限管理
- リクエストコンテキストへのユーザー情報追加

## 📝 詳細説明

### 1. JWT関連パッケージインストール

```bash
npm install jsonwebtoken
npm install -D @types/jsonwebtoken
```

### 2. JWT設定

**.env.local:**
```env
JWT_SECRET=your-super-secret-key-change-in-production
JWT_EXPIRES_IN=7d
JWT_REFRESH_EXPIRES_IN=30d
```

**src/config/jwt.ts:**
```typescript
export const jwtConfig = {
  secret: process.env.JWT_SECRET || 'default-secret-change-this',
  expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '30d',
  issuer: 'circle-bord',
  audience: 'circle-bord-users'
};
```

### 3. JWT ユーティリティ

**src/utils/jwt.ts:**
```typescript
import jwt from 'jsonwebtoken';
import { jwtConfig } from '../config/jwt';

export interface TokenPayload {
  userId: string;
  email: string;
  teamIds?: number[];
}

export interface DecodedToken extends TokenPayload {
  iat: number;
  exp: number;
  iss: string;
  aud: string;
}

export class JWTService {
  /**
   * アクセストークン生成
   */
  static generateAccessToken(payload: TokenPayload): string {
    return jwt.sign(payload, jwtConfig.secret, {
      expiresIn: jwtConfig.expiresIn,
      issuer: jwtConfig.issuer,
      audience: jwtConfig.audience
    });
  }

  /**
   * リフレッシュトークン生成
   */
  static generateRefreshToken(payload: TokenPayload): string {
    return jwt.sign(
      { ...payload, type: 'refresh' },
      jwtConfig.secret,
      {
        expiresIn: jwtConfig.refreshExpiresIn,
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience
      }
    );
  }

  /**
   * トークンペア生成
   */
  static generateTokenPair(payload: TokenPayload): {
    accessToken: string;
    refreshToken: string;
  } {
    return {
      accessToken: this.generateAccessToken(payload),
      refreshToken: this.generateRefreshToken(payload)
    };
  }

  /**
   * トークン検証
   */
  static verifyToken(token: string): DecodedToken {
    try {
      const decoded = jwt.verify(token, jwtConfig.secret, {
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience
      }) as DecodedToken;
      
      return decoded;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new Error('Token has expired');
      }
      if (error instanceof jwt.JsonWebTokenError) {
        throw new Error('Invalid token');
      }
      throw error;
    }
  }

  /**
   * トークンデコード（検証なし）
   */
  static decodeToken(token: string): DecodedToken | null {
    return jwt.decode(token) as DecodedToken | null;
  }

  /**
   * トークン有効期限チェック
   */
  static isTokenExpired(token: string): boolean {
    const decoded = this.decodeToken(token);
    if (!decoded) return true;
    
    const currentTime = Math.floor(Date.now() / 1000);
    return decoded.exp < currentTime;
  }

  /**
   * トークンから残り有効時間を取得（秒）
   */
  static getTokenRemainingTime(token: string): number {
    const decoded = this.decodeToken(token);
    if (!decoded) return 0;
    
    const currentTime = Math.floor(Date.now() / 1000);
    const remaining = decoded.exp - currentTime;
    
    return remaining > 0 ? remaining : 0;
  }
}
```

### 4. 認証ミドルウェア実装

**src/middlewares/auth.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { JWTService } from '../utils/jwt';
import { UserRepository } from '../repositories/UserRepository';
import { AppDataSource } from '../config/database';

// Requestオブジェクトの型拡張
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        teamIds?: number[];
      };
      token?: string;
    }
  }
}

/**
 * 認証ミドルウェア
 */
export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Authorizationヘッダーからトークン取得
    const authHeader = req.headers.authorization;
    
    if (!authHeader) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'NO_AUTH_HEADER'
      });
      return;
    }

    // Bearer トークン形式チェック
    const parts = authHeader.split(' ');
    if (parts.length !== 2 || parts[0] !== 'Bearer') {
      res.status(401).json({
        error: 'Invalid authorization format',
        code: 'INVALID_AUTH_FORMAT'
      });
      return;
    }

    const token = parts[1];

    // トークン検証
    const decoded = JWTService.verifyToken(token);

    // ユーザー存在確認（オプション）
    const userRepository = new UserRepository(AppDataSource);
    const user = await userRepository.findById(decoded.userId);

    if (!user || !user.isActive) {
      res.status(401).json({
        error: 'User not found or inactive',
        code: 'USER_NOT_FOUND'
      });
      return;
    }

    // リクエストオブジェクトにユーザー情報を追加
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      teamIds: decoded.teamIds
    };
    req.token = token;

    next();
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === 'Token has expired') {
        res.status(401).json({
          error: 'Token has expired',
          code: 'TOKEN_EXPIRED'
        });
        return;
      }
      if (error.message === 'Invalid token') {
        res.status(401).json({
          error: 'Invalid token',
          code: 'INVALID_TOKEN'
        });
        return;
      }
    }
    
    res.status(500).json({
      error: 'Authentication error',
      code: 'AUTH_ERROR'
    });
  }
};

/**
 * オプショナル認証ミドルウェア
 * トークンがあれば検証し、なくても続行
 */
export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader) {
    return next();
  }

  const parts = authHeader.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') {
    return next();
  }

  try {
    const token = parts[1];
    const decoded = JWTService.verifyToken(token);
    
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      teamIds: decoded.teamIds
    };
    req.token = token;
  } catch {
    // エラーは無視して続行
  }

  next();
};

/**
 * 特定のチームメンバーのみアクセス可能
 */
export const requireTeamMembership = (teamIdParam = 'teamId') => {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    if (!req.user) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'NO_AUTH'
      });
      return;
    }

    const teamId = parseInt(req.params[teamIdParam]);
    if (!teamId) {
      res.status(400).json({
        error: 'Team ID required',
        code: 'NO_TEAM_ID'
      });
      return;
    }

    if (!req.user.teamIds?.includes(teamId)) {
      res.status(403).json({
        error: 'Access denied',
        code: 'NOT_TEAM_MEMBER'
      });
      return;
    }

    next();
  };
};
```

### 5. 認証ヘルパー関数

**src/utils/authHelpers.ts:**
```typescript
import { Response } from 'express';
import { JWTService } from './jwt';

/**
 * トークンをCookieに設定
 */
export const setAuthCookies = (
  res: Response,
  accessToken: string,
  refreshToken: string
): void => {
  // アクセストークン（HTTPOnly, Secure）
  res.cookie('accessToken', accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7日
  });

  // リフレッシュトークン（HTTPOnly, Secure）
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 30 * 24 * 60 * 60 * 1000 // 30日
  });
};

/**
 * 認証Cookieをクリア
 */
export const clearAuthCookies = (res: Response): void => {
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');
};

/**
 * トークンレスポンス生成
 */
export const createTokenResponse = (
  userId: string,
  email: string,
  teamIds?: number[]
) => {
  const tokens = JWTService.generateTokenPair({
    userId,
    email,
    teamIds
  });

  return {
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    expiresIn: JWTService.getTokenRemainingTime(tokens.accessToken),
    tokenType: 'Bearer'
  };
};
```

### 6. ミドルウェア使用例

**src/routes/protected.ts:**
```typescript
import { Router } from 'express';
import { authenticate, requireTeamMembership } from '../middlewares/auth';

const router = Router();

// 認証が必要なエンドポイント
router.get('/profile', authenticate, (req, res) => {
  res.json({
    user: req.user
  });
});

// チームメンバーのみアクセス可能
router.get(
  '/teams/:teamId/members',
  authenticate,
  requireTeamMembership('teamId'),
  (req, res) => {
    // チームメンバー一覧を返す
  }
);

export default router;
```

## ✅ 受け入れ条件

- [ ] JWT生成機能が実装されている
- [ ] JWT検証機能が実装されている
- [ ] 認証ミドルウェアが動作する
- [ ] トークン有効期限管理が機能する
- [ ] リフレッシュトークンが実装されている
- [ ] エラーハンドリングが適切
- [ ] Request型にユーザー情報が追加される

## 🔧 技術要件

- jsonwebtoken
- RS256またはHS256アルゴリズム
- 環境変数での秘密鍵管理

## ⏱️ 見積もり時間
10時間

## 🔗 依存関係
- P1-005: CRUD API実装（完了必須）

## 🧪 テスト方針

### JWT ユーティリティテスト
```typescript
describe('JWTService', () => {
  it('should generate valid access token', () => {
    const payload = { userId: '123', email: 'test@example.com' };
    const token = JWTService.generateAccessToken(payload);
    
    const decoded = JWTService.verifyToken(token);
    expect(decoded.userId).toBe(payload.userId);
    expect(decoded.email).toBe(payload.email);
  });

  it('should reject expired token', () => {
    // 有効期限切れトークンのテスト
  });

  it('should reject invalid token', () => {
    expect(() => JWTService.verifyToken('invalid-token'))
      .toThrow('Invalid token');
  });
});
```

## 📌 注意事項

- JWT秘密鍵は絶対にコードにハードコーディングしない
- 本番環境では強固な秘密鍵を使用
- トークンの有効期限は適切に設定
- HTTPOnly Cookieを使用してXSS対策
- CORS設定と合わせてセキュリティを強化

## 🏷️ ラベル
`auth`, `jwt`, `middleware`, `security`, `phase2`

## 📅 作成日
2025-09-08