# ãƒã‚±ãƒƒãƒˆ P2-001: JWTèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…

## ğŸ“‹ æ¦‚è¦
JSON Web Token (JWT)ã‚’ä½¿ç”¨ã—ãŸèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’å®Ÿè£…ã—ã€APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä¿è­·ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- JWTç”Ÿæˆãƒ»æ¤œè¨¼æ©Ÿèƒ½ã®å®Ÿè£…
- èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®ä½œæˆ
- ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æœŸé™ç®¡ç†
- ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¸ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±è¿½åŠ 

## ğŸ“ è©³ç´°èª¬æ˜

### 1. JWTé–¢é€£ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
npm install jsonwebtoken
npm install -D @types/jsonwebtoken
```

### 2. JWTè¨­å®š

**.env.local:**
```env
JWT_SECRET=your-super-secret-key-change-in-production
JWT_EXPIRES_IN=7d
JWT_REFRESH_EXPIRES_IN=30d
```

**src/config/jwt.ts:**
```typescript
export const jwtConfig = {
  secret: process.env.JWT_SECRET || 'default-secret-change-this',
  expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '30d',
  issuer: 'circle-bord',
  audience: 'circle-bord-users'
};
```

### 3. JWT ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

**src/utils/jwt.ts:**
```typescript
import jwt from 'jsonwebtoken';
import { jwtConfig } from '../config/jwt';

export interface TokenPayload {
  userId: string;
  email: string;
  teamIds?: number[];
}

export interface DecodedToken extends TokenPayload {
  iat: number;
  exp: number;
  iss: string;
  aud: string;
}

export class JWTService {
  /**
   * ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
   */
  static generateAccessToken(payload: TokenPayload): string {
    return jwt.sign(payload, jwtConfig.secret, {
      expiresIn: jwtConfig.expiresIn,
      issuer: jwtConfig.issuer,
      audience: jwtConfig.audience
    });
  }

  /**
   * ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
   */
  static generateRefreshToken(payload: TokenPayload): string {
    return jwt.sign(
      { ...payload, type: 'refresh' },
      jwtConfig.secret,
      {
        expiresIn: jwtConfig.refreshExpiresIn,
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience
      }
    );
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ç”Ÿæˆ
   */
  static generateTokenPair(payload: TokenPayload): {
    accessToken: string;
    refreshToken: string;
  } {
    return {
      accessToken: this.generateAccessToken(payload),
      refreshToken: this.generateRefreshToken(payload)
    };
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
   */
  static verifyToken(token: string): DecodedToken {
    try {
      const decoded = jwt.verify(token, jwtConfig.secret, {
        issuer: jwtConfig.issuer,
        audience: jwtConfig.audience
      }) as DecodedToken;
      
      return decoded;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new Error('Token has expired');
      }
      if (error instanceof jwt.JsonWebTokenError) {
        throw new Error('Invalid token');
      }
      throw error;
    }
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆæ¤œè¨¼ãªã—ï¼‰
   */
  static decodeToken(token: string): DecodedToken | null {
    return jwt.decode(token) as DecodedToken | null;
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯
   */
  static isTokenExpired(token: string): boolean {
    const decoded = this.decodeToken(token);
    if (!decoded) return true;
    
    const currentTime = Math.floor(Date.now() / 1000);
    return decoded.exp < currentTime;
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ã‹ã‚‰æ®‹ã‚Šæœ‰åŠ¹æ™‚é–“ã‚’å–å¾—ï¼ˆç§’ï¼‰
   */
  static getTokenRemainingTime(token: string): number {
    const decoded = this.decodeToken(token);
    if (!decoded) return 0;
    
    const currentTime = Math.floor(Date.now() / 1000);
    const remaining = decoded.exp - currentTime;
    
    return remaining > 0 ? remaining : 0;
  }
}
```

### 4. èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…

**src/middlewares/auth.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { JWTService } from '../utils/jwt';
import { UserRepository } from '../repositories/UserRepository';
import { AppDataSource } from '../config/database';

// Requestã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹æ‹¡å¼µ
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        teamIds?: number[];
      };
      token?: string;
    }
  }
}

/**
 * èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 */
export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Authorizationãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—
    const authHeader = req.headers.authorization;
    
    if (!authHeader) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'NO_AUTH_HEADER'
      });
      return;
    }

    // Bearer ãƒˆãƒ¼ã‚¯ãƒ³å½¢å¼ãƒã‚§ãƒƒã‚¯
    const parts = authHeader.split(' ');
    if (parts.length !== 2 || parts[0] !== 'Bearer') {
      res.status(401).json({
        error: 'Invalid authorization format',
        code: 'INVALID_AUTH_FORMAT'
      });
      return;
    }

    const token = parts[1];

    // ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
    const decoded = JWTService.verifyToken(token);

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å­˜åœ¨ç¢ºèªï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    const userRepository = new UserRepository(AppDataSource);
    const user = await userRepository.findById(decoded.userId);

    if (!user || !user.isActive) {
      res.status(401).json({
        error: 'User not found or inactive',
        code: 'USER_NOT_FOUND'
      });
      return;
    }

    // ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’è¿½åŠ 
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      teamIds: decoded.teamIds
    };
    req.token = token;

    next();
  } catch (error) {
    if (error instanceof Error) {
      if (error.message === 'Token has expired') {
        res.status(401).json({
          error: 'Token has expired',
          code: 'TOKEN_EXPIRED'
        });
        return;
      }
      if (error.message === 'Invalid token') {
        res.status(401).json({
          error: 'Invalid token',
          code: 'INVALID_TOKEN'
        });
        return;
      }
    }
    
    res.status(500).json({
      error: 'Authentication error',
      code: 'AUTH_ERROR'
    });
  }
};

/**
 * ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
 * ãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚ã‚Œã°æ¤œè¨¼ã—ã€ãªãã¦ã‚‚ç¶šè¡Œ
 */
export const optionalAuth = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader) {
    return next();
  }

  const parts = authHeader.split(' ');
  if (parts.length !== 2 || parts[0] !== 'Bearer') {
    return next();
  }

  try {
    const token = parts[1];
    const decoded = JWTService.verifyToken(token);
    
    req.user = {
      id: decoded.userId,
      email: decoded.email,
      teamIds: decoded.teamIds
    };
    req.token = token;
  } catch {
    // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã—ã¦ç¶šè¡Œ
  }

  next();
};

/**
 * ç‰¹å®šã®ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
 */
export const requireTeamMembership = (teamIdParam = 'teamId') => {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    if (!req.user) {
      res.status(401).json({
        error: 'Authentication required',
        code: 'NO_AUTH'
      });
      return;
    }

    const teamId = parseInt(req.params[teamIdParam]);
    if (!teamId) {
      res.status(400).json({
        error: 'Team ID required',
        code: 'NO_TEAM_ID'
      });
      return;
    }

    if (!req.user.teamIds?.includes(teamId)) {
      res.status(403).json({
        error: 'Access denied',
        code: 'NOT_TEAM_MEMBER'
      });
      return;
    }

    next();
  };
};
```

### 5. èªè¨¼ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°

**src/utils/authHelpers.ts:**
```typescript
import { Response } from 'express';
import { JWTService } from './jwt';

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³ã‚’Cookieã«è¨­å®š
 */
export const setAuthCookies = (
  res: Response,
  accessToken: string,
  refreshToken: string
): void => {
  // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆHTTPOnly, Secureï¼‰
  res.cookie('accessToken', accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7æ—¥
  });

  // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆHTTPOnly, Secureï¼‰
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 30 * 24 * 60 * 60 * 1000 // 30æ—¥
  });
};

/**
 * èªè¨¼Cookieã‚’ã‚¯ãƒªã‚¢
 */
export const clearAuthCookies = (res: Response): void => {
  res.clearCookie('accessToken');
  res.clearCookie('refreshToken');
};

/**
 * ãƒˆãƒ¼ã‚¯ãƒ³ãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”Ÿæˆ
 */
export const createTokenResponse = (
  userId: string,
  email: string,
  teamIds?: number[]
) => {
  const tokens = JWTService.generateTokenPair({
    userId,
    email,
    teamIds
  });

  return {
    accessToken: tokens.accessToken,
    refreshToken: tokens.refreshToken,
    expiresIn: JWTService.getTokenRemainingTime(tokens.accessToken),
    tokenType: 'Bearer'
  };
};
```

### 6. ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ä½¿ç”¨ä¾‹

**src/routes/protected.ts:**
```typescript
import { Router } from 'express';
import { authenticate, requireTeamMembership } from '../middlewares/auth';

const router = Router();

// èªè¨¼ãŒå¿…è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
router.get('/profile', authenticate, (req, res) => {
  res.json({
    user: req.user
  });
});

// ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã®ã¿ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
router.get(
  '/teams/:teamId/members',
  authenticate,
  requireTeamMembership('teamId'),
  (req, res) => {
    // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ä¸€è¦§ã‚’è¿”ã™
  }
);

export default router;
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] JWTç”Ÿæˆæ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] JWTæ¤œè¨¼æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ãŒå‹•ä½œã™ã‚‹
- [ ] ãƒˆãƒ¼ã‚¯ãƒ³æœ‰åŠ¹æœŸé™ç®¡ç†ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒé©åˆ‡
- [ ] Requestå‹ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¿½åŠ ã•ã‚Œã‚‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- jsonwebtoken
- RS256ã¾ãŸã¯HS256ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
- ç’°å¢ƒå¤‰æ•°ã§ã®ç§˜å¯†éµç®¡ç†

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
10æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P1-005: CRUD APIå®Ÿè£…ï¼ˆå®Œäº†å¿…é ˆï¼‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

### JWT ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ
```typescript
describe('JWTService', () => {
  it('should generate valid access token', () => {
    const payload = { userId: '123', email: 'test@example.com' };
    const token = JWTService.generateAccessToken(payload);
    
    const decoded = JWTService.verifyToken(token);
    expect(decoded.userId).toBe(payload.userId);
    expect(decoded.email).toBe(payload.email);
  });

  it('should reject expired token', () => {
    // æœ‰åŠ¹æœŸé™åˆ‡ã‚Œãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ†ã‚¹ãƒˆ
  });

  it('should reject invalid token', () => {
    expect(() => JWTService.verifyToken('invalid-token'))
      .toThrow('Invalid token');
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- JWTç§˜å¯†éµã¯çµ¶å¯¾ã«ã‚³ãƒ¼ãƒ‰ã«ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã—ãªã„
- æœ¬ç•ªç’°å¢ƒã§ã¯å¼·å›ºãªç§˜å¯†éµã‚’ä½¿ç”¨
- ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ã¯é©åˆ‡ã«è¨­å®š
- HTTPOnly Cookieã‚’ä½¿ç”¨ã—ã¦XSSå¯¾ç­–
- CORSè¨­å®šã¨åˆã‚ã›ã¦ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å¼·åŒ–

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`auth`, `jwt`, `middleware`, `security`, `phase2`

## ğŸ“… ä½œæˆæ—¥
2025-09-08