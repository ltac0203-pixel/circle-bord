# チケット P2-002: パスワード管理システム

## 📋 概要
bcryptを使用した安全なパスワードハッシュ化とパスワードリセット機能を実装する。

## 🎯 目標
- パスワードハッシュ化の実装
- パスワード強度検証
- パスワードリセット機能
- パスワード変更履歴管理

## 📝 詳細説明

### 1. パスワードサービス実装

**src/services/PasswordService.ts:**
```typescript
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import { UserRepository } from '../repositories/UserRepository';

export class PasswordService {
  private static readonly SALT_ROUNDS = 10;
  private static readonly MIN_PASSWORD_LENGTH = 8;
  private static readonly PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/;

  /**
   * パスワードのハッシュ化
   */
  static async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, this.SALT_ROUNDS);
  }

  /**
   * パスワード検証
   */
  static async verifyPassword(
    password: string,
    hashedPassword: string
  ): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }

  /**
   * パスワード強度チェック
   */
  static validatePasswordStrength(password: string): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (password.length < this.MIN_PASSWORD_LENGTH) {
      errors.push(`パスワードは${this.MIN_PASSWORD_LENGTH}文字以上必要です`);
    }

    if (!/[a-z]/.test(password)) {
      errors.push('小文字を含む必要があります');
    }

    if (!/[A-Z]/.test(password)) {
      errors.push('大文字を含む必要があります');
    }

    if (!/\d/.test(password)) {
      errors.push('数字を含む必要があります');
    }

    if (!/[@$!%*?&]/.test(password)) {
      errors.push('特殊文字(@$!%*?&)を含む必要があります');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * リセットトークン生成
   */
  static generateResetToken(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * リセットトークンハッシュ化
   */
  static hashResetToken(token: string): string {
    return crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
  }
}
```

### 2. パスワードリセットEntity

**src/entities/PasswordReset.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('password_resets')
export class PasswordReset {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: string;

  @Column({ unique: true })
  token: string;

  @Column()
  expiresAt: Date;

  @Column({ default: false })
  used: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;
}
```

### 3. パスワード変更履歴

**src/entities/PasswordHistory.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('password_history')
export class PasswordHistory {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: string;

  @Column()
  passwordHash: string;

  @CreateDateColumn()
  changedAt: Date;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;
}
```

### 4. パスワードリセットサービス

**src/services/PasswordResetService.ts:**
```typescript
import { PasswordReset } from '../entities/PasswordReset';
import { PasswordService } from './PasswordService';
import { EmailService } from './EmailService';
import { UserRepository } from '../repositories/UserRepository';

export class PasswordResetService {
  constructor(
    private passwordResetRepository: Repository<PasswordReset>,
    private userRepository: UserRepository,
    private emailService: EmailService
  ) {}

  /**
   * パスワードリセット要求
   */
  async requestPasswordReset(email: string): Promise<void> {
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      // セキュリティのため、ユーザーが存在しなくても成功を返す
      return;
    }

    // 既存のトークンを無効化
    await this.passwordResetRepository.update(
      { userId: user.id, used: false },
      { used: true }
    );

    // 新しいトークン生成
    const token = PasswordService.generateResetToken();
    const hashedToken = PasswordService.hashResetToken(token);

    const resetRequest = this.passwordResetRepository.create({
      userId: user.id,
      token: hashedToken,
      expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1時間後
    });

    await this.passwordResetRepository.save(resetRequest);

    // メール送信
    await this.emailService.sendPasswordResetEmail(user.email, token);
  }

  /**
   * パスワードリセット実行
   */
  async resetPassword(token: string, newPassword: string): Promise<void> {
    const hashedToken = PasswordService.hashResetToken(token);
    
    const resetRequest = await this.passwordResetRepository.findOne({
      where: {
        token: hashedToken,
        used: false
      },
      relations: ['user']
    });

    if (!resetRequest) {
      throw new Error('無効なトークンです');
    }

    if (resetRequest.expiresAt < new Date()) {
      throw new Error('トークンの有効期限が切れています');
    }

    // パスワード強度チェック
    const validation = PasswordService.validatePasswordStrength(newPassword);
    if (!validation.isValid) {
      throw new Error(validation.errors.join(', '));
    }

    // パスワード更新
    const hashedPassword = await PasswordService.hashPassword(newPassword);
    await this.userRepository.update(resetRequest.userId, {
      password: hashedPassword
    });

    // トークンを使用済みにする
    resetRequest.used = true;
    await this.passwordResetRepository.save(resetRequest);

    // パスワード履歴を記録
    await this.recordPasswordHistory(resetRequest.userId, hashedPassword);
  }

  /**
   * パスワード履歴記録
   */
  private async recordPasswordHistory(
    userId: string,
    passwordHash: string
  ): Promise<void> {
    // 実装省略
  }
}
```

### 5. パスワード管理エンドポイント

**src/controllers/PasswordController.ts:**
```typescript
import { Request, Response } from 'express';
import { PasswordResetService } from '../services/PasswordResetService';

export class PasswordController {
  constructor(private passwordResetService: PasswordResetService) {}

  /**
   * パスワードリセット要求
   */
  async requestReset(req: Request, res: Response): Promise<void> {
    const { email } = req.body;

    await this.passwordResetService.requestPasswordReset(email);

    res.json({
      message: 'パスワードリセットメールを送信しました'
    });
  }

  /**
   * パスワードリセット実行
   */
  async resetPassword(req: Request, res: Response): Promise<void> {
    const { token, password } = req.body;

    try {
      await this.passwordResetService.resetPassword(token, password);
      res.json({
        message: 'パスワードをリセットしました'
      });
    } catch (error) {
      res.status(400).json({
        error: error.message
      });
    }
  }

  /**
   * パスワード変更
   */
  async changePassword(req: Request, res: Response): Promise<void> {
    const userId = req.user!.id;
    const { currentPassword, newPassword } = req.body;

    // 実装
  }
}
```

## ✅ 受け入れ条件

- [ ] パスワードが安全にハッシュ化される
- [ ] パスワード強度検証が機能する
- [ ] パスワードリセット機能が動作する
- [ ] リセットトークンに有効期限がある
- [ ] パスワード履歴が記録される
- [ ] 同じパスワードの再利用を防ぐ

## 🔧 技術要件

- bcrypt（ハッシュ化）
- crypto（トークン生成）
- メール送信機能

## ⏱️ 見積もり時間
6時間

## 🔗 依存関係
- P1-003: Entity定義実装
- P2-001: JWT認証ミドルウェア実装

## 🧪 テスト方針

```typescript
describe('PasswordService', () => {
  it('should hash password', async () => {
    const password = 'Test@1234';
    const hash = await PasswordService.hashPassword(password);
    
    expect(hash).not.toBe(password);
    expect(hash.length).toBeGreaterThan(20);
  });

  it('should validate password strength', () => {
    const weak = PasswordService.validatePasswordStrength('weak');
    expect(weak.isValid).toBe(false);
    
    const strong = PasswordService.validatePasswordStrength('Strong@123');
    expect(strong.isValid).toBe(true);
  });
});
```

## 📌 注意事項

- パスワードは平文で保存しない
- リセットトークンは一度きりの使用
- タイミング攻撃を防ぐ実装
- レート制限を実装する

## 🏷️ ラベル
`security`, `password`, `authentication`, `phase2`

## 📅 作成日
2025-09-08