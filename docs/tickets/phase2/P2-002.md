# ãƒã‚±ãƒƒãƒˆ P2-002: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

## ğŸ“‹ æ¦‚è¦
bcryptã‚’ä½¿ç”¨ã—ãŸå®‰å…¨ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ã®å®Ÿè£…
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦æ¤œè¨¼
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´å±¥æ­´ç®¡ç†

## ğŸ“ è©³ç´°èª¬æ˜

### 1. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

**src/services/PasswordService.ts:**
```typescript
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import { UserRepository } from '../repositories/UserRepository';

export class PasswordService {
  private static readonly SALT_ROUNDS = 10;
  private static readonly MIN_PASSWORD_LENGTH = 8;
  private static readonly PASSWORD_REGEX = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/;

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥åŒ–
   */
  static async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, this.SALT_ROUNDS);
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼
   */
  static async verifyPassword(
    password: string,
    hashedPassword: string
  ): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
   */
  static validatePasswordStrength(password: string): {
    isValid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (password.length < this.MIN_PASSWORD_LENGTH) {
      errors.push(`ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯${this.MIN_PASSWORD_LENGTH}æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™`);
    }

    if (!/[a-z]/.test(password)) {
      errors.push('å°æ–‡å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }

    if (!/[A-Z]/.test(password)) {
      errors.push('å¤§æ–‡å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }

    if (!/\d/.test(password)) {
      errors.push('æ•°å­—ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }

    if (!/[@$!%*?&]/.test(password)) {
      errors.push('ç‰¹æ®Šæ–‡å­—(@$!%*?&)ã‚’å«ã‚€å¿…è¦ãŒã‚ã‚Šã¾ã™');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
   */
  static generateResetToken(): string {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ãƒãƒƒã‚·ãƒ¥åŒ–
   */
  static hashResetToken(token: string): string {
    return crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
  }
}
```

### 2. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆEntity

**src/entities/PasswordReset.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('password_resets')
export class PasswordReset {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: string;

  @Column({ unique: true })
  token: string;

  @Column()
  expiresAt: Date;

  @Column({ default: false })
  used: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;
}
```

### 3. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´å±¥æ­´

**src/entities/PasswordHistory.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('password_history')
export class PasswordHistory {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  userId: string;

  @Column()
  passwordHash: string;

  @CreateDateColumn()
  changedAt: Date;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;
}
```

### 4. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆã‚µãƒ¼ãƒ“ã‚¹

**src/services/PasswordResetService.ts:**
```typescript
import { PasswordReset } from '../entities/PasswordReset';
import { PasswordService } from './PasswordService';
import { EmailService } from './EmailService';
import { UserRepository } from '../repositories/UserRepository';

export class PasswordResetService {
  constructor(
    private passwordResetRepository: Repository<PasswordReset>,
    private userRepository: UserRepository,
    private emailService: EmailService
  ) {}

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆè¦æ±‚
   */
  async requestPasswordReset(email: string): Promise<void> {
    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªãã¦ã‚‚æˆåŠŸã‚’è¿”ã™
      return;
    }

    // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç„¡åŠ¹åŒ–
    await this.passwordResetRepository.update(
      { userId: user.id, used: false },
      { used: true }
    );

    // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    const token = PasswordService.generateResetToken();
    const hashedToken = PasswordService.hashResetToken(token);

    const resetRequest = this.passwordResetRepository.create({
      userId: user.id,
      token: hashedToken,
      expiresAt: new Date(Date.now() + 60 * 60 * 1000) // 1æ™‚é–“å¾Œ
    });

    await this.passwordResetRepository.save(resetRequest);

    // ãƒ¡ãƒ¼ãƒ«é€ä¿¡
    await this.emailService.sendPasswordResetEmail(user.email, token);
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ
   */
  async resetPassword(token: string, newPassword: string): Promise<void> {
    const hashedToken = PasswordService.hashResetToken(token);
    
    const resetRequest = await this.passwordResetRepository.findOne({
      where: {
        token: hashedToken,
        used: false
      },
      relations: ['user']
    });

    if (!resetRequest) {
      throw new Error('ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ã§ã™');
    }

    if (resetRequest.expiresAt < new Date()) {
      throw new Error('ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã¾ã™');
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ãƒã‚§ãƒƒã‚¯
    const validation = PasswordService.validatePasswordStrength(newPassword);
    if (!validation.isValid) {
      throw new Error(validation.errors.join(', '));
    }

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ›´æ–°
    const hashedPassword = await PasswordService.hashPassword(newPassword);
    await this.userRepository.update(resetRequest.userId, {
      password: hashedPassword
    });

    // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨æ¸ˆã¿ã«ã™ã‚‹
    resetRequest.used = true;
    await this.passwordResetRepository.save(resetRequest);

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å±¥æ­´ã‚’è¨˜éŒ²
    await this.recordPasswordHistory(resetRequest.userId, hashedPassword);
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å±¥æ­´è¨˜éŒ²
   */
  private async recordPasswordHistory(
    userId: string,
    passwordHash: string
  ): Promise<void> {
    // å®Ÿè£…çœç•¥
  }
}
```

### 5. ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç®¡ç†ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

**src/controllers/PasswordController.ts:**
```typescript
import { Request, Response } from 'express';
import { PasswordResetService } from '../services/PasswordResetService';

export class PasswordController {
  constructor(private passwordResetService: PasswordResetService) {}

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆè¦æ±‚
   */
  async requestReset(req: Request, res: Response): Promise<void> {
    const { email } = req.body;

    await this.passwordResetService.requestPasswordReset(email);

    res.json({
      message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆãƒ¡ãƒ¼ãƒ«ã‚’é€ä¿¡ã—ã¾ã—ãŸ'
    });
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆå®Ÿè¡Œ
   */
  async resetPassword(req: Request, res: Response): Promise<void> {
    const { token, password } = req.body;

    try {
      await this.passwordResetService.resetPassword(token, password);
      res.json({
        message: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ'
      });
    } catch (error) {
      res.status(400).json({
        error: error.message
      });
    }
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¤‰æ›´
   */
  async changePassword(req: Request, res: Response): Promise<void> {
    const userId = req.user!.id;
    const { currentPassword, newPassword } = req.body;

    // å®Ÿè£…
  }
}
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå®‰å…¨ã«ãƒãƒƒã‚·ãƒ¥åŒ–ã•ã‚Œã‚‹
- [ ] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦æ¤œè¨¼ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹
- [ ] ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã«æœ‰åŠ¹æœŸé™ãŒã‚ã‚‹
- [ ] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å±¥æ­´ãŒè¨˜éŒ²ã•ã‚Œã‚‹
- [ ] åŒã˜ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®å†åˆ©ç”¨ã‚’é˜²ã

## ğŸ”§ æŠ€è¡“è¦ä»¶

- bcryptï¼ˆãƒãƒƒã‚·ãƒ¥åŒ–ï¼‰
- cryptoï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼‰
- ãƒ¡ãƒ¼ãƒ«é€ä¿¡æ©Ÿèƒ½

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
6æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P1-003: Entityå®šç¾©å®Ÿè£…
- P2-001: JWTèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

```typescript
describe('PasswordService', () => {
  it('should hash password', async () => {
    const password = 'Test@1234';
    const hash = await PasswordService.hashPassword(password);
    
    expect(hash).not.toBe(password);
    expect(hash.length).toBeGreaterThan(20);
  });

  it('should validate password strength', () => {
    const weak = PasswordService.validatePasswordStrength('weak');
    expect(weak.isValid).toBe(false);
    
    const strong = PasswordService.validatePasswordStrength('Strong@123');
    expect(strong.isValid).toBe(true);
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯å¹³æ–‡ã§ä¿å­˜ã—ãªã„
- ãƒªã‚»ãƒƒãƒˆãƒˆãƒ¼ã‚¯ãƒ³ã¯ä¸€åº¦ãã‚Šã®ä½¿ç”¨
- ã‚¿ã‚¤ãƒŸãƒ³ã‚°æ”»æ’ƒã‚’é˜²ãå®Ÿè£…
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’å®Ÿè£…ã™ã‚‹

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`security`, `password`, `authentication`, `phase2`

## ğŸ“… ä½œæˆæ—¥
2025-09-08