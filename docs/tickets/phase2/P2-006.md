# チケット P2-006: エラーハンドリング強化

## 📋 概要
認証システム全体のエラーハンドリングを強化し、一貫性のあるエラーレスポンスを実装する。

## 🎯 目標
- カスタムエラークラスの実装
- グローバルエラーハンドラー
- エラーログ記録
- ユーザーフレンドリーなエラーメッセージ

## 📝 詳細説明

### 1. カスタムエラークラス

**src/errors/AppError.ts:**
```typescript
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;
  public readonly isOperational: boolean;

  constructor(
    message: string,
    statusCode: number,
    code: string,
    isOperational = true
  ) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, code = 'VALIDATION_ERROR') {
    super(message, 400, code);
  }
}

export class AuthenticationError extends AppError {
  constructor(message = '認証が必要です', code = 'AUTH_REQUIRED') {
    super(message, 401, code);
  }
}

export class ForbiddenError extends AppError {
  constructor(message = 'アクセス権限がありません', code = 'FORBIDDEN') {
    super(message, 403, code);
  }
}

export class NotFoundError extends AppError {
  constructor(message = 'リソースが見つかりません', code = 'NOT_FOUND') {
    super(message, 404, code);
  }
}

export class ConflictError extends AppError {
  constructor(message = 'リソースが既に存在します', code = 'CONFLICT') {
    super(message, 409, code);
  }
}

export class RateLimitError extends AppError {
  constructor(message = 'リクエスト数が制限を超えました', code = 'RATE_LIMIT') {
    super(message, 429, code);
  }
}
```

### 2. グローバルエラーハンドラー

**src/middlewares/errorHandler.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../errors/AppError';
import { logger } from '../utils/logger';

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // エラーログ記録
  logger.error({
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userId: req.user?.id
  });

  // AppErrorの場合
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      error: {
        message: err.message,
        code: err.code,
        statusCode: err.statusCode
      }
    });
    return;
  }

  // バリデーションエラー（class-validator）
  if (err.name === 'ValidationError') {
    res.status(400).json({
      error: {
        message: 'バリデーションエラー',
        code: 'VALIDATION_ERROR',
        statusCode: 400,
        details: err.message
      }
    });
    return;
  }

  // JWT関連エラー
  if (err.name === 'JsonWebTokenError') {
    res.status(401).json({
      error: {
        message: '無効なトークンです',
        code: 'INVALID_TOKEN',
        statusCode: 401
      }
    });
    return;
  }

  if (err.name === 'TokenExpiredError') {
    res.status(401).json({
      error: {
        message: 'トークンの有効期限が切れています',
        code: 'TOKEN_EXPIRED',
        statusCode: 401
      }
    });
    return;
  }

  // データベースエラー
  if (err.name === 'QueryFailedError') {
    res.status(500).json({
      error: {
        message: 'データベースエラーが発生しました',
        code: 'DATABASE_ERROR',
        statusCode: 500
      }
    });
    return;
  }

  // その他のエラー
  const isDevelopment = process.env.NODE_ENV === 'development';
  res.status(500).json({
    error: {
      message: isDevelopment ? err.message : 'サーバーエラーが発生しました',
      code: 'INTERNAL_SERVER_ERROR',
      statusCode: 500,
      ...(isDevelopment && { stack: err.stack })
    }
  });
};

// 非同期エラーハンドラーラッパー
export const asyncHandler = (fn: Function) => {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
};
```

### 3. エラーロギング

**src/utils/logger.ts:**
```typescript
import winston from 'winston';
import path from 'path';

const logDir = 'logs';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  defaultMeta: { service: 'circle-bord-api' },
  transports: [
    // エラーログ
    new winston.transports.File({
      filename: path.join(logDir, 'error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),
    // 全ログ
    new winston.transports.File({
      filename: path.join(logDir, 'combined.log'),
      maxsize: 5242880,
      maxFiles: 5
    })
  ]
});

// 開発環境ではコンソール出力
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

export { logger };
```

### 4. フロントエンドエラーハンドリング

**src/utils/errorHandler.ts (フロントエンド):**
```typescript
import { AxiosError } from 'axios';

interface ErrorResponse {
  message: string;
  code: string;
  statusCode: number;
  details?: any;
}

export const handleApiError = (error: unknown): string => {
  if (error instanceof AxiosError) {
    const data = error.response?.data as { error?: ErrorResponse };
    
    if (data?.error) {
      switch (data.error.code) {
        case 'AUTH_REQUIRED':
          return 'ログインが必要です';
        case 'TOKEN_EXPIRED':
          return 'セッションの有効期限が切れました';
        case 'VALIDATION_ERROR':
          return data.error.message || '入力内容を確認してください';
        case 'RATE_LIMIT':
          return 'しばらく時間をおいてから再度お試しください';
        default:
          return data.error.message || 'エラーが発生しました';
      }
    }

    // ネットワークエラー
    if (!error.response) {
      return 'ネットワークエラーが発生しました';
    }
  }

  return 'エラーが発生しました';
};
```

### 5. エラーバウンダリコンポーネント

**src/components/ErrorBoundary.tsx:**
```typescript
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught:', error, errorInfo);
    
    // エラーログをサーバーに送信
    if (process.env.NODE_ENV === 'production') {
      // logErrorToService(error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="error-boundary">
          <h2>エラーが発生しました</h2>
          <p>申し訳ございません。問題が発生しました。</p>
          <button onClick={() => window.location.reload()}>
            ページを再読み込み
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

## ✅ 受け入れ条件

- [ ] カスタムエラークラスが実装されている
- [ ] グローバルエラーハンドラーが動作する
- [ ] エラーログが記録される
- [ ] 適切なHTTPステータスコードが返される
- [ ] フロントエンドでエラーが適切に表示される
- [ ] エラーバウンダリが実装されている

## 🔧 技術要件

- winston（ロギング）
- カスタムエラークラス
- Express エラーミドルウェア

## ⏱️ 見積もり時間
6時間

## 🔗 依存関係
- P2-005: 認証API統合

## 🧪 テスト方針

```typescript
describe('Error Handling', () => {
  it('should handle validation errors', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({ email: 'invalid' });

    expect(response.status).toBe(400);
    expect(response.body.error.code).toBe('VALIDATION_ERROR');
  });

  it('should handle authentication errors', async () => {
    const response = await request(app)
      .get('/api/users/me');

    expect(response.status).toBe(401);
    expect(response.body.error.code).toBe('AUTH_REQUIRED');
  });
});
```

## 📌 注意事項

- 本番環境では詳細なエラー情報を隠す
- センシティブな情報をログに含めない
- レート制限エラーを適切に処理

## 🏷️ ラベル
`error-handling`, `logging`, `security`, `phase2`

## 📅 作成日
2025-09-08