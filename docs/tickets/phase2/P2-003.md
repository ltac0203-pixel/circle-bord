# ãƒã‚±ãƒƒãƒˆ P2-003: ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥æ©Ÿèƒ½

## ğŸ“‹ æ¦‚è¦
ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®è‡ªå‹•æ›´æ–°ã¨ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®å®Ÿè£…
- ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½
- è‡ªå‹•ãƒˆãƒ¼ã‚¯ãƒ³æ›´æ–°
- ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

## ğŸ“ è©³ç´°èª¬æ˜

### 1. ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³Entity

**src/entities/RefreshToken.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('refresh_tokens')
export class RefreshToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  userId: string;

  @Column({ unique: true })
  token: string;

  @Column()
  expiresAt: Date;

  @Column({ default: false })
  revoked: boolean;

  @Column({ nullable: true })
  replacedByToken?: string;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ nullable: true })
  userAgent?: string;

  @Column({ nullable: true })
  ipAddress?: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;
}
```

### 2. ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚µãƒ¼ãƒ“ã‚¹

**src/services/TokenService.ts:**
```typescript
import { RefreshToken } from '../entities/RefreshToken';
import { JWTService } from '../utils/jwt';
import { Repository } from 'typeorm';

export class TokenService {
  constructor(
    private refreshTokenRepository: Repository<RefreshToken>,
    private userRepository: UserRepository
  ) {}

  /**
   * ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ç™ºè¡Œã¨ä¿å­˜
   */
  async issueRefreshToken(
    userId: string,
    userAgent?: string,
    ipAddress?: string
  ): Promise<string> {
    const token = JWTService.generateRefreshToken({ userId });
    
    const refreshToken = this.refreshTokenRepository.create({
      userId,
      token,
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30æ—¥
      userAgent,
      ipAddress
    });

    await this.refreshTokenRepository.save(refreshToken);
    return token;
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ï¼ˆãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãï¼‰
   */
  async refreshTokens(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
  }> {
    // æ—¢å­˜ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
    const existingToken = await this.refreshTokenRepository.findOne({
      where: { token: refreshToken, revoked: false },
      relations: ['user']
    });

    if (!existingToken) {
      throw new Error('Invalid refresh token');
    }

    if (existingToken.expiresAt < new Date()) {
      throw new Error('Refresh token expired');
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—
    const user = existingToken.user;

    // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ç”Ÿæˆ
    const newAccessToken = JWTService.generateAccessToken({
      userId: user.id,
      email: user.email
    });

    const newRefreshToken = await this.issueRefreshToken(
      user.id,
      existingToken.userAgent,
      existingToken.ipAddress
    );

    // å¤ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç„¡åŠ¹åŒ–ï¼ˆãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
    existingToken.revoked = true;
    existingToken.replacedByToken = newRefreshToken;
    await this.refreshTokenRepository.save(existingToken);

    return {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken
    };
  }

  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ç„¡åŠ¹åŒ–ï¼ˆãƒ­ã‚°ã‚¢ã‚¦ãƒˆï¼‰
   */
  async revokeToken(token: string): Promise<void> {
    await this.refreshTokenRepository.update(
      { token },
      { revoked: true }
    );
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¨ãƒˆãƒ¼ã‚¯ãƒ³ç„¡åŠ¹åŒ–
   */
  async revokeAllUserTokens(userId: string): Promise<void> {
    await this.refreshTokenRepository.update(
      { userId, revoked: false },
      { revoked: true }
    );
  }

  /**
   * æœŸé™åˆ‡ã‚Œãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  async cleanupExpiredTokens(): Promise<void> {
    await this.refreshTokenRepository
      .createQueryBuilder()
      .delete()
      .where('expiresAt < :now', { now: new Date() })
      .execute();
  }
}
```

### 3. ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

**src/controllers/AuthController.ts:**
```typescript
export class AuthController {
  /**
   * ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
   */
  async refreshToken(req: Request, res: Response): Promise<void> {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        res.status(400).json({ error: 'Refresh token required' });
        return;
      }

      const tokens = await this.tokenService.refreshTokens(refreshToken);

      res.json({
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        tokenType: 'Bearer',
        expiresIn: 3600
      });
    } catch (error) {
      res.status(401).json({ error: error.message });
    }
  }

  /**
   * ãƒ­ã‚°ã‚¢ã‚¦ãƒˆï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ç„¡åŠ¹åŒ–ï¼‰
   */
  async logout(req: Request, res: Response): Promise<void> {
    const { refreshToken } = req.body;

    if (refreshToken) {
      await this.tokenService.revokeToken(refreshToken);
    }

    res.json({ message: 'Logged out successfully' });
  }
}
```

### 4. è‡ªå‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

**src/middlewares/autoRefresh.ts:**
```typescript
export const autoRefresh = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  if (req.token) {
    const remainingTime = JWTService.getTokenRemainingTime(req.token);
    
    // 5åˆ†ä»¥å†…ã«æœŸé™åˆ‡ã‚Œã®å ´åˆã€è‡ªå‹•ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
    if (remainingTime < 300) {
      res.setHeader('X-Token-Refresh-Required', 'true');
    }
  }
  
  next();
};
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ãŒç™ºè¡Œã•ã‚Œã‚‹
- [ ] ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè£…ã•ã‚Œã‚‹
- [ ] æœŸé™åˆ‡ã‚Œãƒˆãƒ¼ã‚¯ãƒ³ãŒè‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã•ã‚Œã‚‹
- [ ] ãƒ­ã‚°ã‚¢ã‚¦ãƒˆæ™‚ã«ãƒˆãƒ¼ã‚¯ãƒ³ãŒç„¡åŠ¹åŒ–ã•ã‚Œã‚‹
- [ ] ä¸æ­£ãªãƒˆãƒ¼ã‚¯ãƒ³é€£é–ã‚’æ¤œå‡ºã§ãã‚‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®æ°¸ç¶šåŒ–
- ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
- å®šæœŸã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¸ãƒ§ãƒ–

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
8æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P2-001: JWTèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢å®Ÿè£…

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

```typescript
describe('TokenService', () => {
  it('should refresh tokens with rotation', async () => {
    const oldRefreshToken = await tokenService.issueRefreshToken('user-id');
    const tokens = await tokenService.refreshTokens(oldRefreshToken);
    
    expect(tokens.accessToken).toBeDefined();
    expect(tokens.refreshToken).not.toBe(oldRefreshToken);
    
    // å¤ã„ãƒˆãƒ¼ã‚¯ãƒ³ã¯ä½¿ç”¨ä¸å¯
    await expect(tokenService.refreshTokens(oldRefreshToken))
      .rejects.toThrow('Invalid refresh token');
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¼æ´©å¯¾ç­–
- ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã«ã‚ˆã‚‹å†åˆ©ç”¨é˜²æ­¢
- ç•°å¸¸ãªãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`auth`, `token`, `refresh`, `security`, `phase2`

## ğŸ“… ä½œæˆæ—¥
2025-09-08