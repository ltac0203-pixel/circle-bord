# チケット P2-003: トークンリフレッシュ機能

## 📋 概要
アクセストークンの自動更新とリフレッシュトークンローテーションを実装する。

## 🎯 目標
- リフレッシュトークンの実装
- トークンローテーション機能
- 自動トークン更新
- セッション管理

## 📝 詳細説明

### 1. リフレッシュトークンEntity

**src/entities/RefreshToken.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('refresh_tokens')
export class RefreshToken {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  userId: string;

  @Column({ unique: true })
  token: string;

  @Column()
  expiresAt: Date;

  @Column({ default: false })
  revoked: boolean;

  @Column({ nullable: true })
  replacedByToken?: string;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ nullable: true })
  userAgent?: string;

  @Column({ nullable: true })
  ipAddress?: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'userId' })
  user: User;
}
```

### 2. トークンリフレッシュサービス

**src/services/TokenService.ts:**
```typescript
import { RefreshToken } from '../entities/RefreshToken';
import { JWTService } from '../utils/jwt';
import { Repository } from 'typeorm';

export class TokenService {
  constructor(
    private refreshTokenRepository: Repository<RefreshToken>,
    private userRepository: UserRepository
  ) {}

  /**
   * リフレッシュトークン発行と保存
   */
  async issueRefreshToken(
    userId: string,
    userAgent?: string,
    ipAddress?: string
  ): Promise<string> {
    const token = JWTService.generateRefreshToken({ userId });
    
    const refreshToken = this.refreshTokenRepository.create({
      userId,
      token,
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30日
      userAgent,
      ipAddress
    });

    await this.refreshTokenRepository.save(refreshToken);
    return token;
  }

  /**
   * トークンリフレッシュ（ローテーション付き）
   */
  async refreshTokens(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
  }> {
    // 既存トークン検証
    const existingToken = await this.refreshTokenRepository.findOne({
      where: { token: refreshToken, revoked: false },
      relations: ['user']
    });

    if (!existingToken) {
      throw new Error('Invalid refresh token');
    }

    if (existingToken.expiresAt < new Date()) {
      throw new Error('Refresh token expired');
    }

    // ユーザー情報取得
    const user = existingToken.user;

    // 新しいトークンペア生成
    const newAccessToken = JWTService.generateAccessToken({
      userId: user.id,
      email: user.email
    });

    const newRefreshToken = await this.issueRefreshToken(
      user.id,
      existingToken.userAgent,
      existingToken.ipAddress
    );

    // 古いトークンを無効化（ローテーション）
    existingToken.revoked = true;
    existingToken.replacedByToken = newRefreshToken;
    await this.refreshTokenRepository.save(existingToken);

    return {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken
    };
  }

  /**
   * トークン無効化（ログアウト）
   */
  async revokeToken(token: string): Promise<void> {
    await this.refreshTokenRepository.update(
      { token },
      { revoked: true }
    );
  }

  /**
   * ユーザーの全トークン無効化
   */
  async revokeAllUserTokens(userId: string): Promise<void> {
    await this.refreshTokenRepository.update(
      { userId, revoked: false },
      { revoked: true }
    );
  }

  /**
   * 期限切れトークンのクリーンアップ
   */
  async cleanupExpiredTokens(): Promise<void> {
    await this.refreshTokenRepository
      .createQueryBuilder()
      .delete()
      .where('expiresAt < :now', { now: new Date() })
      .execute();
  }
}
```

### 3. リフレッシュエンドポイント

**src/controllers/AuthController.ts:**
```typescript
export class AuthController {
  /**
   * トークンリフレッシュ
   */
  async refreshToken(req: Request, res: Response): Promise<void> {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        res.status(400).json({ error: 'Refresh token required' });
        return;
      }

      const tokens = await this.tokenService.refreshTokens(refreshToken);

      res.json({
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        tokenType: 'Bearer',
        expiresIn: 3600
      });
    } catch (error) {
      res.status(401).json({ error: error.message });
    }
  }

  /**
   * ログアウト（トークン無効化）
   */
  async logout(req: Request, res: Response): Promise<void> {
    const { refreshToken } = req.body;

    if (refreshToken) {
      await this.tokenService.revokeToken(refreshToken);
    }

    res.json({ message: 'Logged out successfully' });
  }
}
```

### 4. 自動リフレッシュミドルウェア

**src/middlewares/autoRefresh.ts:**
```typescript
export const autoRefresh = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  if (req.token) {
    const remainingTime = JWTService.getTokenRemainingTime(req.token);
    
    // 5分以内に期限切れの場合、自動リフレッシュ
    if (remainingTime < 300) {
      res.setHeader('X-Token-Refresh-Required', 'true');
    }
  }
  
  next();
};
```

## ✅ 受け入れ条件

- [ ] リフレッシュトークンが発行される
- [ ] トークンローテーションが実装される
- [ ] 期限切れトークンが自動クリーンアップされる
- [ ] ログアウト時にトークンが無効化される
- [ ] 不正なトークン連鎖を検出できる

## 🔧 技術要件

- リフレッシュトークンの永続化
- トークンローテーション
- 定期クリーンアップジョブ

## ⏱️ 見積もり時間
8時間

## 🔗 依存関係
- P2-001: JWT認証ミドルウェア実装

## 🧪 テスト方針

```typescript
describe('TokenService', () => {
  it('should refresh tokens with rotation', async () => {
    const oldRefreshToken = await tokenService.issueRefreshToken('user-id');
    const tokens = await tokenService.refreshTokens(oldRefreshToken);
    
    expect(tokens.accessToken).toBeDefined();
    expect(tokens.refreshToken).not.toBe(oldRefreshToken);
    
    // 古いトークンは使用不可
    await expect(tokenService.refreshTokens(oldRefreshToken))
      .rejects.toThrow('Invalid refresh token');
  });
});
```

## 📌 注意事項

- リフレッシュトークンの漏洩対策
- トークンローテーションによる再利用防止
- 異常なリフレッシュパターンの検出

## 🏷️ ラベル
`auth`, `token`, `refresh`, `security`, `phase2`

## 📅 作成日
2025-09-08