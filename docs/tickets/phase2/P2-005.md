# チケット P2-005: 認証API統合

## 📋 概要
認証関連のAPIエンドポイントを実装し、フロントエンドと統合する。

## 🎯 目標
- ログイン/ログアウトAPI
- ユーザー登録API
- 認証状態確認API
- メール認証機能

## 📝 詳細説明

### 1. 認証コントローラー実装

**src/controllers/AuthController.ts:**
```typescript
import { Request, Response } from 'express';
import { AuthService } from '../services/AuthService';
import { JWTService } from '../utils/jwt';
import { validate } from 'class-validator';

export class AuthController {
  constructor(private authService: AuthService) {}

  /**
   * ユーザー登録
   */
  async register(req: Request, res: Response): Promise<void> {
    try {
      const { email, password, name } = req.body;

      // バリデーション
      const errors = await this.authService.validateRegistration(email, password, name);
      if (errors.length > 0) {
        res.status(400).json({ errors });
        return;
      }

      // ユーザー作成
      const user = await this.authService.register(email, password, name);

      // トークン生成
      const tokens = JWTService.generateTokenPair({
        userId: user.id,
        email: user.email
      });

      res.status(201).json({
        user: {
          id: user.id,
          email: user.email,
          name: user.name
        },
        ...tokens
      });
    } catch (error) {
      res.status(400).json({ 
        message: error.message 
      });
    }
  }

  /**
   * ログイン
   */
  async login(req: Request, res: Response): Promise<void> {
    try {
      const { email, password } = req.body;

      const user = await this.authService.authenticate(email, password);

      if (!user) {
        res.status(401).json({ 
          message: 'メールアドレスまたはパスワードが正しくありません' 
        });
        return;
      }

      // チーム情報を含めてトークン生成
      const userTeams = await this.authService.getUserTeams(user.id);
      const tokens = JWTService.generateTokenPair({
        userId: user.id,
        email: user.email,
        teamIds: userTeams.map(ut => ut.teamId)
      });

      res.json({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          teams: userTeams
        },
        ...tokens
      });
    } catch (error) {
      res.status(500).json({ 
        message: 'ログイン処理中にエラーが発生しました' 
      });
    }
  }

  /**
   * 現在のユーザー情報取得
   */
  async me(req: Request, res: Response): Promise<void> {
    try {
      const userId = req.user!.id;
      const user = await this.authService.getUserWithTeams(userId);

      res.json(user);
    } catch (error) {
      res.status(500).json({ 
        message: 'ユーザー情報の取得に失敗しました' 
      });
    }
  }

  /**
   * メールアドレス確認
   */
  async verifyEmail(req: Request, res: Response): Promise<void> {
    try {
      const { token } = req.params;
      
      await this.authService.verifyEmail(token);
      
      res.json({ 
        message: 'メールアドレスが確認されました' 
      });
    } catch (error) {
      res.status(400).json({ 
        message: 'メール確認トークンが無効です' 
      });
    }
  }
}
```

### 2. 認証サービス実装

**src/services/AuthService.ts:**
```typescript
import { User } from '../entities/User';
import { UserRepository } from '../repositories/UserRepository';
import { PasswordService } from './PasswordService';
import { EmailService } from './EmailService';
import * as crypto from 'crypto';

export class AuthService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService
  ) {}

  /**
   * ユーザー認証
   */
  async authenticate(email: string, password: string): Promise<User | null> {
    const user = await this.userRepository.findByEmail(email);
    
    if (!user) {
      return null;
    }

    const isValid = await PasswordService.verifyPassword(password, user.password);
    
    if (!isValid) {
      return null;
    }

    if (!user.isActive) {
      throw new Error('アカウントが無効化されています');
    }

    return user;
  }

  /**
   * ユーザー登録
   */
  async register(email: string, password: string, name: string): Promise<User> {
    // 重複チェック
    const existing = await this.userRepository.findByEmail(email);
    if (existing) {
      throw new Error('このメールアドレスは既に使用されています');
    }

    // パスワード強度チェック
    const validation = PasswordService.validatePasswordStrength(password);
    if (!validation.isValid) {
      throw new Error(validation.errors.join(', '));
    }

    // ユーザー作成
    const hashedPassword = await PasswordService.hashPassword(password);
    const user = await this.userRepository.create({
      email,
      password: hashedPassword,
      name,
      isActive: false // メール確認まで無効
    });

    // 確認メール送信
    const verificationToken = crypto.randomBytes(32).toString('hex');
    await this.emailService.sendVerificationEmail(email, verificationToken);

    return user;
  }

  /**
   * 登録バリデーション
   */
  async validateRegistration(
    email: string,
    password: string,
    name: string
  ): Promise<string[]> {
    const errors: string[] = [];

    if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      errors.push('有効なメールアドレスを入力してください');
    }

    const passwordValidation = PasswordService.validatePasswordStrength(password);
    if (!passwordValidation.isValid) {
      errors.push(...passwordValidation.errors);
    }

    if (!name || name.length < 2) {
      errors.push('名前は2文字以上で入力してください');
    }

    return errors;
  }

  /**
   * ユーザーのチーム情報取得
   */
  async getUserTeams(userId: string): Promise<any[]> {
    const user = await this.userRepository.findWithTeams(userId);
    return user?.userTeams || [];
  }

  /**
   * チーム情報を含むユーザー取得
   */
  async getUserWithTeams(userId: string): Promise<any> {
    const user = await this.userRepository.findWithTeams(userId);
    
    if (!user) {
      throw new Error('ユーザーが見つかりません');
    }

    return {
      id: user.id,
      email: user.email,
      name: user.name,
      teams: user.userTeams.map(ut => ({
        id: ut.team.id,
        name: ut.team.name,
        role: ut.role
      }))
    };
  }

  /**
   * メールアドレス確認
   */
  async verifyEmail(token: string): Promise<void> {
    // トークン検証と有効化処理
    // 実装省略
  }
}
```

### 3. 認証ルート設定

**src/routes/auth.ts:**
```typescript
import { Router } from 'express';
import { AuthController } from '../controllers/AuthController';
import { AuthService } from '../services/AuthService';
import { authenticate } from '../middlewares/auth';
import { rateLimiter } from '../middlewares/rateLimiter';

const router = Router();

const authService = new AuthService(userRepository, emailService);
const authController = new AuthController(authService);

// レート制限付きエンドポイント
router.post('/register', rateLimiter(5, 15), authController.register);
router.post('/login', rateLimiter(5, 15), authController.login);
router.post('/logout', authenticate, authController.logout);
router.post('/refresh', authController.refreshToken);

// 認証必須エンドポイント
router.get('/me', authenticate, authController.me);
router.get('/verify/:token', authController.verifyEmail);

export default router;
```

## ✅ 受け入れ条件

- [ ] ユーザー登録APIが動作する
- [ ] ログインAPIが動作する
- [ ] トークンが正しく発行される
- [ ] 認証状態が確認できる
- [ ] メール確認機能が動作する
- [ ] レート制限が実装される

## 🔧 技術要件

- Express.js
- バリデーション
- レート制限
- メール送信

## ⏱️ 見積もり時間
8時間

## 🔗 依存関係
- P2-001: JWT認証ミドルウェア実装
- P2-002: パスワード管理システム

## 🧪 テスト方針

```typescript
describe('Auth API', () => {
  it('should register new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        email: 'test@example.com',
        password: 'Test@1234',
        name: 'Test User'
      });

    expect(response.status).toBe(201);
    expect(response.body.user.email).toBe('test@example.com');
    expect(response.body.accessToken).toBeDefined();
  });
});
```

## 📌 注意事項

- パスワードをレスポンスに含めない
- レート制限でブルートフォース攻撃を防ぐ
- エラーメッセージで情報漏洩しない

## 🏷️ ラベル
`api`, `auth`, `integration`, `phase2`

## 📅 作成日
2025-09-08