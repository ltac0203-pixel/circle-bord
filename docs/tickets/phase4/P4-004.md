# チケット P4-004: エラーハンドリング実装

## 📋 概要
API連携におけるエラーハンドリングを統一し、ユーザーフレンドリーなエラー表示を実装する。

## 🎯 目標
- グローバルエラーハンドラー
- エラー表示コンポーネント
- リトライ機能
- エラー通知

## 📝 詳細説明

### 1. エラー表示コンポーネント

**src/components/common/ErrorMessage.tsx:**
```typescript
interface ErrorMessageProps {
  error: Error | null;
  onRetry?: () => void;
  fullPage?: boolean;
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({
  error,
  onRetry,
  fullPage = false
}) => {
  const errorMessage = getErrorMessage(error);
  const errorCode = getErrorCode(error);

  const content = (
    <div className="error-message">
      <div className="error-icon">
        <AlertCircle size={48} />
      </div>
      
      <h3>エラーが発生しました</h3>
      
      <p className="error-description">{errorMessage}</p>
      
      {errorCode && (
        <p className="error-code">エラーコード: {errorCode}</p>
      )}
      
      {onRetry && (
        <button className="btn-retry" onClick={onRetry}>
          再試行
        </button>
      )}
      
      <details className="error-details">
        <summary>詳細情報</summary>
        <pre>{JSON.stringify(error, null, 2)}</pre>
      </details>
    </div>
  );

  if (fullPage) {
    return (
      <div className="error-page">
        {content}
      </div>
    );
  }

  return content;
};
```

### 2. エラートースト通知

**src/components/common/ErrorToast.tsx:**
```typescript
import { toast, ToastOptions } from 'react-toastify';

const defaultOptions: ToastOptions = {
  position: 'top-right',
  autoClose: 5000,
  hideProgressBar: false,
  closeOnClick: true,
  pauseOnHover: true,
  draggable: true
};

export const showError = (error: unknown) => {
  const message = getErrorMessage(error);
  const code = getErrorCode(error);
  
  toast.error(
    <div>
      <strong>{message}</strong>
      {code && <div className="text-sm">Code: {code}</div>}
    </div>,
    defaultOptions
  );
};

export const showSuccess = (message: string) => {
  toast.success(message, defaultOptions);
};

export const showWarning = (message: string) => {
  toast.warning(message, defaultOptions);
};

export const showInfo = (message: string) => {
  toast.info(message, defaultOptions);
};
```

### 3. APIエラーインターセプター

**src/services/apiErrorInterceptor.ts:**
```typescript
import axios, { AxiosError } from 'axios';
import { showError } from '../components/common/ErrorToast';

export const setupErrorInterceptor = (queryClient: QueryClient) => {
  axios.interceptors.response.use(
    (response) => response,
    async (error: AxiosError) => {
      const { response } = error;
      
      if (response) {
        switch (response.status) {
          case 401:
            // 認証エラー
            queryClient.clear();
            window.location.href = '/signin';
            break;
            
          case 403:
            showError('アクセス権限がありません');
            break;
            
          case 404:
            showError('リソースが見つかりません');
            break;
            
          case 429:
            showError('リクエスト数が制限を超えました。しばらくお待ちください。');
            break;
            
          case 500:
            showError('サーバーエラーが発生しました');
            break;
            
          default:
            showError(error);
        }
      } else if (error.request) {
        // ネットワークエラー
        showError('ネットワークエラーが発生しました');
      } else {
        showError('予期しないエラーが発生しました');
      }
      
      return Promise.reject(error);
    }
  );
};
```

### 4. エラーリトライロジック

**src/hooks/useRetry.ts:**
```typescript
interface UseRetryOptions {
  maxAttempts?: number;
  delay?: number;
  backoff?: boolean;
}

export const useRetry = <T>(
  fn: () => Promise<T>,
  options: UseRetryOptions = {}
) => {
  const {
    maxAttempts = 3,
    delay = 1000,
    backoff = true
  } = options;

  const [attempt, setAttempt] = useState(0);
  const [isRetrying, setIsRetrying] = useState(false);

  const retry = useCallback(async () => {
    setIsRetrying(true);
    
    for (let i = 0; i < maxAttempts; i++) {
      try {
        setAttempt(i + 1);
        const result = await fn();
        setIsRetrying(false);
        return result;
      } catch (error) {
        if (i === maxAttempts - 1) {
          setIsRetrying(false);
          throw error;
        }
        
        const waitTime = backoff ? delay * Math.pow(2, i) : delay;
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }, [fn, maxAttempts, delay, backoff]);

  return {
    retry,
    attempt,
    isRetrying,
    canRetry: attempt < maxAttempts
  };
};
```

### 5. エラーリカバリーコンポーネント

**src/components/common/ErrorRecovery.tsx:**
```typescript
interface ErrorRecoveryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: Error; retry: () => void }>;
}

export const ErrorRecovery: React.FC<ErrorRecoveryProps> = ({
  children,
  fallback: Fallback
}) => {
  const queryClient = useQueryClient();
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event?.query?.state?.error) {
        setError(event.query.state.error as Error);
      }
    });

    return unsubscribe;
  }, [queryClient]);

  const retry = () => {
    setError(null);
    queryClient.invalidateQueries();
  };

  if (error) {
    if (Fallback) {
      return <Fallback error={error} retry={retry} />;
    }
    
    return (
      <ErrorMessage
        error={error}
        onRetry={retry}
        fullPage
      />
    );
  }

  return <>{children}</>;
};
```

## ✅ 受け入れ条件

- [ ] エラーが適切に表示される
- [ ] リトライ機能が動作する
- [ ] エラー通知が表示される
- [ ] ネットワークエラーが処理される
- [ ] 認証エラーが適切に処理される

## 🔧 技術要件

- Axios インターセプター
- React Error Boundary
- Toast通知

## ⏱️ 見積もり時間
8時間

## 🔗 依存関係
- P4-003: React Query統合

## 🧪 テスト方針

```typescript
describe('Error Handling', () => {
  it('should display error message', () => {
    const error = new Error('Test error');
    const { getByText } = render(<ErrorMessage error={error} />);
    
    expect(getByText('Test error')).toBeInTheDocument();
  });

  it('should retry on error', async () => {
    const mockFn = jest.fn()
      .mockRejectedValueOnce(new Error('First fail'))
      .mockResolvedValueOnce('Success');
    
    const { result } = renderHook(() => useRetry(mockFn));
    
    const response = await result.current.retry();
    
    expect(response).toBe('Success');
    expect(mockFn).toHaveBeenCalledTimes(2);
  });
});
```

## 📌 注意事項

- ユーザーフレンドリーなメッセージ
- エラー詳細の適切な表示レベル
- リトライの無限ループ防止

## 🏷️ ラベル
`error-handling`, `ui`, `ux`, `phase4`

## 📅 作成日
2025-09-08