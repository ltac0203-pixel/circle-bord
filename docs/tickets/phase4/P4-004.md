# ãƒã‚±ãƒƒãƒˆ P4-004: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å®Ÿè£…

## ğŸ“‹ æ¦‚è¦
APIé€£æºã«ãŠã‘ã‚‹ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’çµ±ä¸€ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
- ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
- ã‚¨ãƒ©ãƒ¼é€šçŸ¥

## ğŸ“ è©³ç´°èª¬æ˜

### 1. ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

**src/components/common/ErrorMessage.tsx:**
```typescript
interface ErrorMessageProps {
  error: Error | null;
  onRetry?: () => void;
  fullPage?: boolean;
}

export const ErrorMessage: React.FC<ErrorMessageProps> = ({
  error,
  onRetry,
  fullPage = false
}) => {
  const errorMessage = getErrorMessage(error);
  const errorCode = getErrorCode(error);

  const content = (
    <div className="error-message">
      <div className="error-icon">
        <AlertCircle size={48} />
      </div>
      
      <h3>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</h3>
      
      <p className="error-description">{errorMessage}</p>
      
      {errorCode && (
        <p className="error-code">ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰: {errorCode}</p>
      )}
      
      {onRetry && (
        <button className="btn-retry" onClick={onRetry}>
          å†è©¦è¡Œ
        </button>
      )}
      
      <details className="error-details">
        <summary>è©³ç´°æƒ…å ±</summary>
        <pre>{JSON.stringify(error, null, 2)}</pre>
      </details>
    </div>
  );

  if (fullPage) {
    return (
      <div className="error-page">
        {content}
      </div>
    );
  }

  return content;
};
```

### 2. ã‚¨ãƒ©ãƒ¼ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥

**src/components/common/ErrorToast.tsx:**
```typescript
import { toast, ToastOptions } from 'react-toastify';

const defaultOptions: ToastOptions = {
  position: 'top-right',
  autoClose: 5000,
  hideProgressBar: false,
  closeOnClick: true,
  pauseOnHover: true,
  draggable: true
};

export const showError = (error: unknown) => {
  const message = getErrorMessage(error);
  const code = getErrorCode(error);
  
  toast.error(
    <div>
      <strong>{message}</strong>
      {code && <div className="text-sm">Code: {code}</div>}
    </div>,
    defaultOptions
  );
};

export const showSuccess = (message: string) => {
  toast.success(message, defaultOptions);
};

export const showWarning = (message: string) => {
  toast.warning(message, defaultOptions);
};

export const showInfo = (message: string) => {
  toast.info(message, defaultOptions);
};
```

### 3. APIã‚¨ãƒ©ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼

**src/services/apiErrorInterceptor.ts:**
```typescript
import axios, { AxiosError } from 'axios';
import { showError } from '../components/common/ErrorToast';

export const setupErrorInterceptor = (queryClient: QueryClient) => {
  axios.interceptors.response.use(
    (response) => response,
    async (error: AxiosError) => {
      const { response } = error;
      
      if (response) {
        switch (response.status) {
          case 401:
            // èªè¨¼ã‚¨ãƒ©ãƒ¼
            queryClient.clear();
            window.location.href = '/signin';
            break;
            
          case 403:
            showError('ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“');
            break;
            
          case 404:
            showError('ãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            break;
            
          case 429:
            showError('ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•°ãŒåˆ¶é™ã‚’è¶…ãˆã¾ã—ãŸã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚');
            break;
            
          case 500:
            showError('ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            break;
            
          default:
            showError(error);
        }
      } else if (error.request) {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
        showError('ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      } else {
        showError('äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
      }
      
      return Promise.reject(error);
    }
  );
};
```

### 4. ã‚¨ãƒ©ãƒ¼ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯

**src/hooks/useRetry.ts:**
```typescript
interface UseRetryOptions {
  maxAttempts?: number;
  delay?: number;
  backoff?: boolean;
}

export const useRetry = <T>(
  fn: () => Promise<T>,
  options: UseRetryOptions = {}
) => {
  const {
    maxAttempts = 3,
    delay = 1000,
    backoff = true
  } = options;

  const [attempt, setAttempt] = useState(0);
  const [isRetrying, setIsRetrying] = useState(false);

  const retry = useCallback(async () => {
    setIsRetrying(true);
    
    for (let i = 0; i < maxAttempts; i++) {
      try {
        setAttempt(i + 1);
        const result = await fn();
        setIsRetrying(false);
        return result;
      } catch (error) {
        if (i === maxAttempts - 1) {
          setIsRetrying(false);
          throw error;
        }
        
        const waitTime = backoff ? delay * Math.pow(2, i) : delay;
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }, [fn, maxAttempts, delay, backoff]);

  return {
    retry,
    attempt,
    isRetrying,
    canRetry: attempt < maxAttempts
  };
};
```

### 5. ã‚¨ãƒ©ãƒ¼ãƒªã‚«ãƒãƒªãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

**src/components/common/ErrorRecovery.tsx:**
```typescript
interface ErrorRecoveryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType<{ error: Error; retry: () => void }>;
}

export const ErrorRecovery: React.FC<ErrorRecoveryProps> = ({
  children,
  fallback: Fallback
}) => {
  const queryClient = useQueryClient();
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const unsubscribe = queryClient.getQueryCache().subscribe((event) => {
      if (event?.query?.state?.error) {
        setError(event.query.state.error as Error);
      }
    });

    return unsubscribe;
  }, [queryClient]);

  const retry = () => {
    setError(null);
    queryClient.invalidateQueries();
  };

  if (error) {
    if (Fallback) {
      return <Fallback error={error} retry={retry} />;
    }
    
    return (
      <ErrorMessage
        error={error}
        onRetry={retry}
        fullPage
      />
    );
  }

  return <>{children}</>;
};
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ã‚¨ãƒ©ãƒ¼ãŒé©åˆ‡ã«è¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ãŒå‹•ä½œã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼é€šçŸ¥ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒå‡¦ç†ã•ã‚Œã‚‹
- [ ] èªè¨¼ã‚¨ãƒ©ãƒ¼ãŒé©åˆ‡ã«å‡¦ç†ã•ã‚Œã‚‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- Axios ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼
- React Error Boundary
- Toasté€šçŸ¥

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
8æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P4-003: React Queryçµ±åˆ

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

```typescript
describe('Error Handling', () => {
  it('should display error message', () => {
    const error = new Error('Test error');
    const { getByText } = render(<ErrorMessage error={error} />);
    
    expect(getByText('Test error')).toBeInTheDocument();
  });

  it('should retry on error', async () => {
    const mockFn = jest.fn()
      .mockRejectedValueOnce(new Error('First fail'))
      .mockResolvedValueOnce('Success');
    
    const { result } = renderHook(() => useRetry(mockFn));
    
    const response = await result.current.retry();
    
    expect(response).toBe('Success');
    expect(mockFn).toHaveBeenCalledTimes(2);
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- ã‚¨ãƒ©ãƒ¼è©³ç´°ã®é©åˆ‡ãªè¡¨ç¤ºãƒ¬ãƒ™ãƒ«
- ãƒªãƒˆãƒ©ã‚¤ã®ç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`error-handling`, `ui`, `ux`, `phase4`

## ğŸ“… ä½œæˆæ—¥
2025-09-08