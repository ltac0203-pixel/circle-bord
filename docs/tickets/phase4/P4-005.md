# ãƒã‚±ãƒƒãƒˆ P4-005: ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ç®¡ç†

## ğŸ“‹ æ¦‚è¦
APIé€šä¿¡ä¸­ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’çµ±ä¸€çš„ã«ç®¡ç†ã—ã€UXã‚’å‘ä¸Šã•ã›ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è¡¨ç¤ºçµ±ä¸€
- ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³å®Ÿè£…
- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼è¡¨ç¤º
- ä¸¦è¡Œãƒªã‚¯ã‚¨ã‚¹ãƒˆç®¡ç†

## ğŸ“ è©³ç´°èª¬æ˜

### 1. ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

**src/components/common/LoadingSpinner.tsx:**
```typescript
interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  fullPage?: boolean;
  message?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'medium',
  fullPage = false,
  message
}) => {
  const spinner = (
    <div className={`loading-spinner ${size}`}>
      <div className="spinner">
        <div className="spinner-circle"></div>
      </div>
      {message && <p className="loading-message">{message}</p>}
    </div>
  );

  if (fullPage) {
    return (
      <div className="loading-overlay">
        {spinner}
      </div>
    );
  }

  return spinner;
};
```

### 2. ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³

**src/components/common/Skeleton.tsx:**
```typescript
interface SkeletonProps {
  variant?: 'text' | 'rect' | 'circle';
  width?: string | number;
  height?: string | number;
  count?: number;
  animation?: 'pulse' | 'wave' | 'none';
}

export const Skeleton: React.FC<SkeletonProps> = ({
  variant = 'text',
  width,
  height,
  count = 1,
  animation = 'pulse'
}) => {
  const elements = Array.from({ length: count }, (_, i) => (
    <div
      key={i}
      className={`skeleton skeleton-${variant} skeleton-${animation}`}
      style={{ width, height }}
    />
  ));

  return <>{elements}</>;
};

// ã‚²ãƒ¼ãƒ ã‚«ãƒ¼ãƒ‰ã‚¹ã‚±ãƒ«ãƒˆãƒ³
export const GameCardSkeleton: React.FC = () => {
  return (
    <div className="game-card skeleton-card">
      <Skeleton variant="rect" height={20} width="60%" />
      <Skeleton variant="text" count={3} />
      <div className="skeleton-footer">
        <Skeleton variant="rect" height={32} width={80} />
        <Skeleton variant="rect" height={32} width={80} />
      </div>
    </div>
  );
};

// ãƒªã‚¹ãƒˆã‚¹ã‚±ãƒ«ãƒˆãƒ³
export const ListSkeleton: React.FC<{ count?: number }> = ({ count = 5 }) => {
  return (
    <div className="list-skeleton">
      {Array.from({ length: count }, (_, i) => (
        <GameCardSkeleton key={i} />
      ))}
    </div>
  );
};
```

### 3. ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ç®¡ç†

**src/contexts/LoadingContext.tsx:**
```typescript
interface LoadingContextType {
  isLoading: boolean;
  loadingCount: number;
  startLoading: (key?: string) => void;
  stopLoading: (key?: string) => void;
  isLoadingKey: (key: string) => boolean;
}

export const LoadingProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [loadingKeys, setLoadingKeys] = useState<Set<string>>(new Set());

  const startLoading = useCallback((key = 'default') => {
    setLoadingKeys(prev => new Set(prev).add(key));
  }, []);

  const stopLoading = useCallback((key = 'default') => {
    setLoadingKeys(prev => {
      const next = new Set(prev);
      next.delete(key);
      return next;
    });
  }, []);

  const isLoadingKey = useCallback((key: string) => {
    return loadingKeys.has(key);
  }, [loadingKeys]);

  const value = {
    isLoading: loadingKeys.size > 0,
    loadingCount: loadingKeys.size,
    startLoading,
    stopLoading,
    isLoadingKey
  };

  return (
    <LoadingContext.Provider value={value}>
      {children}
      {loadingKeys.size > 0 && <GlobalLoadingBar />}
    </LoadingContext.Provider>
  );
};
```

### 4. ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼

**src/components/common/ProgressBar.tsx:**
```typescript
export const GlobalLoadingBar: React.FC = () => {
  const [progress, setProgress] = useState(0);
  const { isLoading } = useLoading();

  useEffect(() => {
    if (isLoading) {
      // æ®µéšçš„ã«é€²è¡Œ
      const timer1 = setTimeout(() => setProgress(30), 100);
      const timer2 = setTimeout(() => setProgress(60), 500);
      const timer3 = setTimeout(() => setProgress(80), 1000);
      
      return () => {
        clearTimeout(timer1);
        clearTimeout(timer2);
        clearTimeout(timer3);
      };
    } else {
      // å®Œäº†
      setProgress(100);
      const timer = setTimeout(() => setProgress(0), 300);
      return () => clearTimeout(timer);
    }
  }, [isLoading]);

  if (progress === 0) return null;

  return (
    <div className="global-progress-bar">
      <div
        className="progress-bar-fill"
        style={{
          width: `${progress}%`,
          transition: progress === 100 ? 'width 0.3s ease' : 'width 1s ease'
        }}
      />
    </div>
  );
};
```

### 5. ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ä»˜ããƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒ

**src/hooks/useLoadingData.ts:**
```typescript
export const useLoadingData = <T>(
  key: string,
  fetcher: () => Promise<T>,
  options?: UseQueryOptions<T>
) => {
  const { startLoading, stopLoading } = useLoading();

  return useQuery<T>(
    key,
    async () => {
      startLoading(key);
      try {
        const data = await fetcher();
        return data;
      } finally {
        stopLoading(key);
      }
    },
    {
      ...options,
      onSettled: () => {
        stopLoading(key);
      }
    }
  );
};
```

### 6. CSS ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```css
/* ã‚¹ãƒ”ãƒŠãƒ¼ */
.spinner-circle {
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-top-color: #4a90e2;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ã‚¹ã‚±ãƒ«ãƒˆãƒ³ */
.skeleton-pulse {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.skeleton-wave {
  position: relative;
  overflow: hidden;
}

.skeleton-wave::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.5),
    transparent
  );
  animation: wave 1.5s linear infinite;
}

@keyframes wave {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] è¤‡æ•°ã®ä¸¦è¡Œãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒç®¡ç†ã•ã‚Œã‚‹
- [ ] ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ»‘ã‚‰ã‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- React Context
- CSS ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- çŠ¶æ…‹ç®¡ç†

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
6æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P4-003: React Queryçµ±åˆ

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

```typescript
describe('Loading Management', () => {
  it('should show loading spinner', () => {
    const { getByRole } = render(<LoadingSpinner />);
    expect(getByRole('status')).toBeInTheDocument();
  });

  it('should manage multiple loading states', () => {
    const { result } = renderHook(() => useLoading());
    
    act(() => {
      result.current.startLoading('fetch1');
      result.current.startLoading('fetch2');
    });
    
    expect(result.current.loadingCount).toBe(2);
    expect(result.current.isLoading).toBe(true);
    
    act(() => {
      result.current.stopLoading('fetch1');
    });
    
    expect(result.current.loadingCount).toBe(1);
    expect(result.current.isLoading).toBe(true);
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¸ã®å½±éŸ¿
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œ
- ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`loading`, `ui`, `ux`, `phase4`

## ğŸ“… ä½œæˆæ—¥
2025-09-08