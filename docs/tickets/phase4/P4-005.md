# チケット P4-005: ローディング状態管理

## 📋 概要
API通信中のローディング状態を統一的に管理し、UXを向上させる。

## 🎯 目標
- ローディング表示統一
- スケルトンスクリーン実装
- プログレスバー表示
- 並行リクエスト管理

## 📝 詳細説明

### 1. ローディングコンポーネント

**src/components/common/LoadingSpinner.tsx:**
```typescript
interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
  fullPage?: boolean;
  message?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'medium',
  fullPage = false,
  message
}) => {
  const spinner = (
    <div className={`loading-spinner ${size}`}>
      <div className="spinner">
        <div className="spinner-circle"></div>
      </div>
      {message && <p className="loading-message">{message}</p>}
    </div>
  );

  if (fullPage) {
    return (
      <div className="loading-overlay">
        {spinner}
      </div>
    );
  }

  return spinner;
};
```

### 2. スケルトンスクリーン

**src/components/common/Skeleton.tsx:**
```typescript
interface SkeletonProps {
  variant?: 'text' | 'rect' | 'circle';
  width?: string | number;
  height?: string | number;
  count?: number;
  animation?: 'pulse' | 'wave' | 'none';
}

export const Skeleton: React.FC<SkeletonProps> = ({
  variant = 'text',
  width,
  height,
  count = 1,
  animation = 'pulse'
}) => {
  const elements = Array.from({ length: count }, (_, i) => (
    <div
      key={i}
      className={`skeleton skeleton-${variant} skeleton-${animation}`}
      style={{ width, height }}
    />
  ));

  return <>{elements}</>;
};

// ゲームカードスケルトン
export const GameCardSkeleton: React.FC = () => {
  return (
    <div className="game-card skeleton-card">
      <Skeleton variant="rect" height={20} width="60%" />
      <Skeleton variant="text" count={3} />
      <div className="skeleton-footer">
        <Skeleton variant="rect" height={32} width={80} />
        <Skeleton variant="rect" height={32} width={80} />
      </div>
    </div>
  );
};

// リストスケルトン
export const ListSkeleton: React.FC<{ count?: number }> = ({ count = 5 }) => {
  return (
    <div className="list-skeleton">
      {Array.from({ length: count }, (_, i) => (
        <GameCardSkeleton key={i} />
      ))}
    </div>
  );
};
```

### 3. グローバルローディング管理

**src/contexts/LoadingContext.tsx:**
```typescript
interface LoadingContextType {
  isLoading: boolean;
  loadingCount: number;
  startLoading: (key?: string) => void;
  stopLoading: (key?: string) => void;
  isLoadingKey: (key: string) => boolean;
}

export const LoadingProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [loadingKeys, setLoadingKeys] = useState<Set<string>>(new Set());

  const startLoading = useCallback((key = 'default') => {
    setLoadingKeys(prev => new Set(prev).add(key));
  }, []);

  const stopLoading = useCallback((key = 'default') => {
    setLoadingKeys(prev => {
      const next = new Set(prev);
      next.delete(key);
      return next;
    });
  }, []);

  const isLoadingKey = useCallback((key: string) => {
    return loadingKeys.has(key);
  }, [loadingKeys]);

  const value = {
    isLoading: loadingKeys.size > 0,
    loadingCount: loadingKeys.size,
    startLoading,
    stopLoading,
    isLoadingKey
  };

  return (
    <LoadingContext.Provider value={value}>
      {children}
      {loadingKeys.size > 0 && <GlobalLoadingBar />}
    </LoadingContext.Provider>
  );
};
```

### 4. プログレスバー

**src/components/common/ProgressBar.tsx:**
```typescript
export const GlobalLoadingBar: React.FC = () => {
  const [progress, setProgress] = useState(0);
  const { isLoading } = useLoading();

  useEffect(() => {
    if (isLoading) {
      // 段階的に進行
      const timer1 = setTimeout(() => setProgress(30), 100);
      const timer2 = setTimeout(() => setProgress(60), 500);
      const timer3 = setTimeout(() => setProgress(80), 1000);
      
      return () => {
        clearTimeout(timer1);
        clearTimeout(timer2);
        clearTimeout(timer3);
      };
    } else {
      // 完了
      setProgress(100);
      const timer = setTimeout(() => setProgress(0), 300);
      return () => clearTimeout(timer);
    }
  }, [isLoading]);

  if (progress === 0) return null;

  return (
    <div className="global-progress-bar">
      <div
        className="progress-bar-fill"
        style={{
          width: `${progress}%`,
          transition: progress === 100 ? 'width 0.3s ease' : 'width 1s ease'
        }}
      />
    </div>
  );
};
```

### 5. ローディング付きデータフェッチ

**src/hooks/useLoadingData.ts:**
```typescript
export const useLoadingData = <T>(
  key: string,
  fetcher: () => Promise<T>,
  options?: UseQueryOptions<T>
) => {
  const { startLoading, stopLoading } = useLoading();

  return useQuery<T>(
    key,
    async () => {
      startLoading(key);
      try {
        const data = await fetcher();
        return data;
      } finally {
        stopLoading(key);
      }
    },
    {
      ...options,
      onSettled: () => {
        stopLoading(key);
      }
    }
  );
};
```

### 6. CSS アニメーション

```css
/* スピナー */
.spinner-circle {
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-top-color: #4a90e2;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* スケルトン */
.skeleton-pulse {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.skeleton-wave {
  position: relative;
  overflow: hidden;
}

.skeleton-wave::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.5),
    transparent
  );
  animation: wave 1.5s linear infinite;
}

@keyframes wave {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}
```

## ✅ 受け入れ条件

- [ ] ローディング状態が表示される
- [ ] スケルトンスクリーンが機能する
- [ ] プログレスバーが表示される
- [ ] 複数の並行リクエストが管理される
- [ ] アニメーションが滑らか

## 🔧 技術要件

- React Context
- CSS アニメーション
- 状態管理

## ⏱️ 見積もり時間
6時間

## 🔗 依存関係
- P4-003: React Query統合

## 🧪 テスト方針

```typescript
describe('Loading Management', () => {
  it('should show loading spinner', () => {
    const { getByRole } = render(<LoadingSpinner />);
    expect(getByRole('status')).toBeInTheDocument();
  });

  it('should manage multiple loading states', () => {
    const { result } = renderHook(() => useLoading());
    
    act(() => {
      result.current.startLoading('fetch1');
      result.current.startLoading('fetch2');
    });
    
    expect(result.current.loadingCount).toBe(2);
    expect(result.current.isLoading).toBe(true);
    
    act(() => {
      result.current.stopLoading('fetch1');
    });
    
    expect(result.current.loadingCount).toBe(1);
    expect(result.current.isLoading).toBe(true);
  });
});
```

## 📌 注意事項

- パフォーマンスへの影響
- アクセシビリティ対応
- メモリリーク防止

## 🏷️ ラベル
`loading`, `ui`, `ux`, `phase4`

## 📅 作成日
2025-09-08