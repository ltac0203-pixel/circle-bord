# ãƒã‚±ãƒƒãƒˆ P4-002: ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ä½œæˆ

## ğŸ“‹ æ¦‚è¦
APIé€£æºç”¨ã®ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ï¼ˆuseGames, useMatchesç­‰ï¼‰ã‚’ä½œæˆã—ã€ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯ã‚’æŠ½è±¡åŒ–ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯å®Ÿè£…
- ãƒ‡ãƒ¼ã‚¿ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°
- æ¥½è¦³çš„æ›´æ–°
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

## ğŸ“ è©³ç´°èª¬æ˜

### 1. useGamesãƒ•ãƒƒã‚¯

**src/hooks/useGames.ts:**
```typescript
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { gameService } from '../services/gameService';

export const useGames = (teamId?: number, filters?: GameFilters) => {
  return useQuery(
    ['games', teamId, filters],
    () => gameService.getGames(teamId!, filters),
    {
      enabled: !!teamId,
      staleTime: 5 * 60 * 1000, // 5åˆ†
      cacheTime: 10 * 60 * 1000, // 10åˆ†
      retry: 2
    }
  );
};

export const useCreateGame = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (data: CreateGameDto) => gameService.createGame(data),
    {
      onSuccess: (newGame) => {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«æ–°ã—ã„è©¦åˆã‚’è¿½åŠ ï¼ˆæ¥½è¦³çš„æ›´æ–°ï¼‰
        queryClient.setQueryData<Game[]>(['games'], (old = []) => {
          return [...old, newGame];
        });
      },
      onError: (error) => {
        console.error('Game creation failed:', error);
      }
    }
  );
};

export const useUpdateGame = () => {
  const queryClient = useQueryClient();

  return useMutation(
    ({ id, data }: { id: number; data: UpdateGameDto }) =>
      gameService.updateGame(id, data),
    {
      onMutate: async ({ id, data }) => {
        // æ¥½è¦³çš„æ›´æ–°
        await queryClient.cancelQueries(['games']);
        
        const previousGames = queryClient.getQueryData<Game[]>(['games']);
        
        queryClient.setQueryData<Game[]>(['games'], (old = []) => {
          return old.map(game =>
            game.id === id ? { ...game, ...data } : game
          );
        });

        return { previousGames };
      },
      onError: (err, variables, context) => {
        // ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
        if (context?.previousGames) {
          queryClient.setQueryData(['games'], context.previousGames);
        }
      },
      onSettled: () => {
        queryClient.invalidateQueries(['games']);
      }
    }
  );
};

export const useDeleteGame = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (id: number) => gameService.deleteGame(id),
    {
      onSuccess: (_, deletedId) => {
        queryClient.setQueryData<Game[]>(['games'], (old = []) => {
          return old.filter(game => game.id !== deletedId);
        });
      }
    }
  );
};
```

### 2. useMatchesãƒ•ãƒƒã‚¯

**src/hooks/useMatches.ts:**
```typescript
export const useMatches = (teamId?: number) => {
  return useQuery(
    ['matches', teamId],
    () => matchService.getTeamMatches(teamId!),
    {
      enabled: !!teamId,
      refetchInterval: 30000 // 30ç§’ã”ã¨ã«æ›´æ–°
    }
  );
};

export const useCreateMatch = () => {
  const queryClient = useQueryClient();

  return useMutation(
    (data: CreateMatchDto) => matchService.createMatch(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['matches']);
        queryClient.invalidateQueries(['games']);
      }
    }
  );
};

export const useMatchActions = (matchId: number) => {
  const queryClient = useQueryClient();

  const confirm = useMutation(
    () => matchService.confirmMatch(matchId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['matches', matchId]);
      }
    }
  );

  const cancel = useMutation(
    () => matchService.cancelMatch(matchId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['matches', matchId]);
      }
    }
  );

  const complete = useMutation(
    (result: MatchResult) => matchService.completeMatch(matchId, result),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['matches', matchId]);
      }
    }
  );

  return { confirm, cancel, complete };
};
```

### 3. æ±ç”¨ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ•ãƒƒã‚¯

**src/hooks/useApiData.ts:**
```typescript
interface UseApiDataOptions<T> {
  key: string | string[];
  fetcher: () => Promise<T>;
  enabled?: boolean;
  refetchInterval?: number;
  onSuccess?: (data: T) => void;
  onError?: (error: Error) => void;
}

export function useApiData<T>({
  key,
  fetcher,
  enabled = true,
  refetchInterval,
  onSuccess,
  onError
}: UseApiDataOptions<T>) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    if (!enabled) return;

    setLoading(true);
    setError(null);

    try {
      const result = await fetcher();
      setData(result);
      onSuccess?.(result);
    } catch (err) {
      const error = err as Error;
      setError(error);
      onError?.(error);
    } finally {
      setLoading(false);
    }
  }, [fetcher, enabled, onSuccess, onError]);

  useEffect(() => {
    fetchData();

    if (refetchInterval) {
      const interval = setInterval(fetchData, refetchInterval);
      return () => clearInterval(interval);
    }
  }, [fetchData, refetchInterval]);

  return {
    data,
    loading,
    error,
    refetch: fetchData,
    mutate: setData
  };
}
```

### 4. ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒƒã‚¯

**src/hooks/useMasterData.ts:**
```typescript
export const useSports = () => {
  return useQuery(
    'sports',
    () => masterDataService.getSports(),
    {
      staleTime: Infinity, // ãƒã‚¹ã‚¿ãƒ‡ãƒ¼ã‚¿ã¯å¤‰æ›´ã•ã‚Œãªã„
      cacheTime: Infinity
    }
  );
};

export const useLocations = () => {
  return useQuery(
    'locations',
    () => masterDataService.getLocations(),
    {
      staleTime: 60 * 60 * 1000, // 1æ™‚é–“
      cacheTime: 24 * 60 * 60 * 1000 // 24æ™‚é–“
    }
  );
};

export const usePrefectures = () => {
  return useQuery(
    'prefectures',
    () => masterDataService.getPrefectures(),
    {
      staleTime: Infinity,
      cacheTime: Infinity
    }
  );
};
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥ãŒé©åˆ‡
- [ ] æ¥½è¦³çš„æ›´æ–°ãŒæ©Ÿèƒ½ã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒé©åˆ‡
- [ ] TypeScriptå‹å®šç¾©ãŒå®Œå…¨

## ğŸ”§ æŠ€è¡“è¦ä»¶

- React Query 3.x
- TypeScript
- ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
10æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P4-001: Dashboard.tsxãƒªãƒ•ã‚¡ã‚¯ã‚¿

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

```typescript
describe('useGames', () => {
  it('should fetch games data', async () => {
    const { result, waitFor } = renderHook(() => useGames(1));
    
    await waitFor(() => result.current.isSuccess);
    
    expect(result.current.data).toHaveLength(3);
  });

  it('should handle optimistic updates', async () => {
    const { result } = renderHook(() => useUpdateGame());
    
    act(() => {
      result.current.mutate({ id: 1, data: { status: 'completed' } });
    });
    
    // UIãŒå³åº§ã«æ›´æ–°ã•ã‚Œã‚‹
    expect(queryClient.getQueryData(['games'])).toContainEqual(
      expect.objectContaining({ id: 1, status: 'completed' })
    );
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- éåº¦ãªAPIå‘¼ã³å‡ºã—ã‚’é¿ã‘ã‚‹
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ç„¡åŠ¹åŒ–ã‚¿ã‚¤ãƒŸãƒ³ã‚°
- æ¥½è¦³çš„æ›´æ–°ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`hooks`, `api`, `cache`, `phase4`

## ğŸ“… ä½œæˆæ—¥
2025-09-08