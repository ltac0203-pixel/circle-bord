# チケット P4-006: オフライン対応実装

## 📋 概要
オフライン時でも基本的な機能が使用できるよう、Service WorkerとIndexedDBを使用したオフライン対応を実装する。

## 🎯 目標
- Service Worker実装
- オフラインキャッシュ
- バックグラウンド同期
- オフライン表示

## 📝 詳細説明

### 1. Service Worker設定

**public/service-worker.js:**
```javascript
const CACHE_NAME = 'circle-bord-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/bundle.js',
  '/manifest.json'
];

// インストール
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// フェッチ
self.addEventListener('fetch', event => {
  // API呼び出しの場合
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then(response => {
          // 成功時はキャッシュを更新
          const responseClone = response.clone();
          caches.open(CACHE_NAME).then(cache => {
            cache.put(event.request, responseClone);
          });
          return response;
        })
        .catch(() => {
          // オフライン時はキャッシュから返す
          return caches.match(event.request);
        })
    );
  } else {
    // 静的リソース
    event.respondWith(
      caches.match(event.request)
        .then(response => response || fetch(event.request))
    );
  }
});

// バックグラウンド同期
self.addEventListener('sync', event => {
  if (event.tag === 'sync-games') {
    event.waitUntil(syncGames());
  }
});
```

### 2. IndexedDB管理

**src/utils/offlineStorage.ts:**
```typescript
import Dexie, { Table } from 'dexie';

interface OfflineGame extends Game {
  syncStatus: 'pending' | 'synced' | 'error';
  localId?: string;
}

class OfflineDatabase extends Dexie {
  games!: Table<OfflineGame>;
  matches!: Table<Match>;
  pendingRequests!: Table<{
    id: string;
    type: string;
    method: string;
    url: string;
    data: any;
    timestamp: number;
  }>;

  constructor() {
    super('CircleBordOffline');
    
    this.version(1).stores({
      games: '++id, teamId, status, syncStatus, localId',
      matches: '++id, teamId, status',
      pendingRequests: '++id, type, timestamp'
    });
  }
}

export const offlineDb = new OfflineDatabase();

// オフラインデータ管理
export class OfflineManager {
  static async saveGame(game: Game): Promise<void> {
    await offlineDb.games.add({
      ...game,
      syncStatus: 'synced'
    });
  }

  static async savePendingGame(gameData: CreateGameDto): Promise<string> {
    const localId = `local-${Date.now()}`;
    
    await offlineDb.games.add({
      ...gameData,
      id: 0,
      syncStatus: 'pending',
      localId,
      createdAt: new Date()
    } as OfflineGame);

    await offlineDb.pendingRequests.add({
      id: localId,
      type: 'game',
      method: 'POST',
      url: '/api/games',
      data: gameData,
      timestamp: Date.now()
    });

    // バックグラウンド同期登録
    if ('serviceWorker' in navigator && 'SyncManager' in window) {
      const registration = await navigator.serviceWorker.ready;
      await (registration as any).sync.register('sync-games');
    }

    return localId;
  }

  static async syncPendingRequests(): Promise<void> {
    const pending = await offlineDb.pendingRequests.toArray();
    
    for (const request of pending) {
      try {
        const response = await fetch(request.url, {
          method: request.method,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('accessToken')}`
          },
          body: JSON.stringify(request.data)
        });

        if (response.ok) {
          // 成功したら削除
          await offlineDb.pendingRequests.delete(request.id);
          
          // ローカルデータを更新
          if (request.type === 'game') {
            const game = await response.json();
            await offlineDb.games
              .where('localId')
              .equals(request.id)
              .modify({ ...game, syncStatus: 'synced' });
          }
        }
      } catch (error) {
        console.error('Sync failed:', error);
      }
    }
  }
}
```

### 3. オフラインフック

**src/hooks/useOffline.ts:**
```typescript
export const useOffline = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [pendingCount, setPendingCount] = useState(0);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      // オンライン復帰時に同期
      OfflineManager.syncPendingRequests();
    };

    const handleOffline = () => {
      setIsOnline(false);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // ペンディング数を監視
    const interval = setInterval(async () => {
      const count = await offlineDb.pendingRequests.count();
      setPendingCount(count);
    }, 5000);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      clearInterval(interval);
    };
  }, []);

  return { isOnline, pendingCount };
};
```

### 4. オフライン対応サービス

**src/services/offlineGameService.ts:**
```typescript
export class OfflineGameService {
  static async getGames(teamId: number): Promise<Game[]> {
    if (navigator.onLine) {
      try {
        const games = await gameService.getGames(teamId);
        // オンライン時はIndexedDBを更新
        await offlineDb.games.clear();
        await offlineDb.games.bulkAdd(games.map(g => ({
          ...g,
          syncStatus: 'synced' as const
        })));
        return games;
      } catch (error) {
        // エラー時はオフラインデータを返す
        return offlineDb.games.where('teamId').equals(teamId).toArray();
      }
    } else {
      // オフライン時はIndexedDBから取得
      return offlineDb.games.where('teamId').equals(teamId).toArray();
    }
  }

  static async createGame(data: CreateGameDto): Promise<Game | string> {
    if (navigator.onLine) {
      try {
        return await gameService.createGame(data);
      } catch (error) {
        // オンラインだが失敗した場合
        return OfflineManager.savePendingGame(data);
      }
    } else {
      // オフライン時は保留
      return OfflineManager.savePendingGame(data);
    }
  }
}
```

### 5. オフライン表示コンポーネント

**src/components/common/OfflineIndicator.tsx:**
```typescript
export const OfflineIndicator: React.FC = () => {
  const { isOnline, pendingCount } = useOffline();

  if (isOnline && pendingCount === 0) {
    return null;
  }

  return (
    <div className={`offline-indicator ${!isOnline ? 'offline' : 'syncing'}`}>
      {!isOnline ? (
        <>
          <WifiOff size={16} />
          <span>オフライン</span>
        </>
      ) : pendingCount > 0 ? (
        <>
          <RefreshCw size={16} className="spinning" />
          <span>同期中 ({pendingCount}件)</span>
        </>
      ) : null}
    </div>
  );
};
```

### 6. Service Worker登録

**src/serviceWorkerRegistration.ts:**
```typescript
export const register = async () => {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register(
        '/service-worker.js'
      );
      
      console.log('Service Worker registered:', registration);

      // 更新チェック
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        if (newWorker) {
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'activated') {
              window.location.reload();
            }
          });
        }
      });
    } catch (error) {
      console.error('Service Worker registration failed:', error);
    }
  }
};
```

## ✅ 受け入れ条件

- [ ] オフライン時にキャッシュデータが表示される
- [ ] オフライン時の操作が保留される
- [ ] オンライン復帰時に自動同期される
- [ ] オフライン状態が表示される
- [ ] Service Workerが正しく動作する

## 🔧 技術要件

- Service Worker
- IndexedDB (Dexie)
- Background Sync API
- Cache API

## ⏱️ 見積もり時間
8時間

## 🔗 依存関係
- P4-001: Dashboard.tsxリファクタ
- P4-003: React Query統合

## 🧪 テスト方針

```typescript
describe('Offline Support', () => {
  it('should save data to IndexedDB when offline', async () => {
    // オフラインモード
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: false
    });

    const gameData = { title: 'Test Game' };
    const result = await OfflineGameService.createGame(gameData);
    
    expect(result).toContain('local-');
    
    const pending = await offlineDb.pendingRequests.toArray();
    expect(pending).toHaveLength(1);
  });

  it('should sync when coming back online', async () => {
    // オンラインに戻る
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: true
    });

    window.dispatchEvent(new Event('online'));
    
    await waitFor(() => {
      expect(offlineDb.pendingRequests.count()).resolves.toBe(0);
    });
  });
});
```

## 📌 注意事項

- ブラウザ互換性
- ストレージ容量制限
- セキュリティ（HTTPSが必要）

## 🏷️ ラベル
`offline`, `pwa`, `service-worker`, `phase4`

## 📅 作成日
2025-09-08