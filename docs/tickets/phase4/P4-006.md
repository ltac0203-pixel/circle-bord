# ãƒã‚±ãƒƒãƒˆ P4-006: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œå®Ÿè£…

## ğŸ“‹ æ¦‚è¦
ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã§ã‚‚åŸºæœ¬çš„ãªæ©Ÿèƒ½ãŒä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã€Service Workerã¨IndexedDBã‚’ä½¿ç”¨ã—ãŸã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- Service Workerå®Ÿè£…
- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã‚­ãƒ£ãƒƒã‚·ãƒ¥
- ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸ
- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³è¡¨ç¤º

## ğŸ“ è©³ç´°èª¬æ˜

### 1. Service Workerè¨­å®š

**public/service-worker.js:**
```javascript
const CACHE_NAME = 'circle-bord-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/bundle.js',
  '/manifest.json'
];

// ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// ãƒ•ã‚§ãƒƒãƒ
self.addEventListener('fetch', event => {
  // APIå‘¼ã³å‡ºã—ã®å ´åˆ
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then(response => {
          // æˆåŠŸæ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ›´æ–°
          const responseClone = response.clone();
          caches.open(CACHE_NAME).then(cache => {
            cache.put(event.request, responseClone);
          });
          return response;
        })
        .catch(() => {
          // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰è¿”ã™
          return caches.match(event.request);
        })
    );
  } else {
    // é™çš„ãƒªã‚½ãƒ¼ã‚¹
    event.respondWith(
      caches.match(event.request)
        .then(response => response || fetch(event.request))
    );
  }
});

// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸ
self.addEventListener('sync', event => {
  if (event.tag === 'sync-games') {
    event.waitUntil(syncGames());
  }
});
```

### 2. IndexedDBç®¡ç†

**src/utils/offlineStorage.ts:**
```typescript
import Dexie, { Table } from 'dexie';

interface OfflineGame extends Game {
  syncStatus: 'pending' | 'synced' | 'error';
  localId?: string;
}

class OfflineDatabase extends Dexie {
  games!: Table<OfflineGame>;
  matches!: Table<Match>;
  pendingRequests!: Table<{
    id: string;
    type: string;
    method: string;
    url: string;
    data: any;
    timestamp: number;
  }>;

  constructor() {
    super('CircleBordOffline');
    
    this.version(1).stores({
      games: '++id, teamId, status, syncStatus, localId',
      matches: '++id, teamId, status',
      pendingRequests: '++id, type, timestamp'
    });
  }
}

export const offlineDb = new OfflineDatabase();

// ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ç®¡ç†
export class OfflineManager {
  static async saveGame(game: Game): Promise<void> {
    await offlineDb.games.add({
      ...game,
      syncStatus: 'synced'
    });
  }

  static async savePendingGame(gameData: CreateGameDto): Promise<string> {
    const localId = `local-${Date.now()}`;
    
    await offlineDb.games.add({
      ...gameData,
      id: 0,
      syncStatus: 'pending',
      localId,
      createdAt: new Date()
    } as OfflineGame);

    await offlineDb.pendingRequests.add({
      id: localId,
      type: 'game',
      method: 'POST',
      url: '/api/games',
      data: gameData,
      timestamp: Date.now()
    });

    // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸç™»éŒ²
    if ('serviceWorker' in navigator && 'SyncManager' in window) {
      const registration = await navigator.serviceWorker.ready;
      await (registration as any).sync.register('sync-games');
    }

    return localId;
  }

  static async syncPendingRequests(): Promise<void> {
    const pending = await offlineDb.pendingRequests.toArray();
    
    for (const request of pending) {
      try {
        const response = await fetch(request.url, {
          method: request.method,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('accessToken')}`
          },
          body: JSON.stringify(request.data)
        });

        if (response.ok) {
          // æˆåŠŸã—ãŸã‚‰å‰Šé™¤
          await offlineDb.pendingRequests.delete(request.id);
          
          // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
          if (request.type === 'game') {
            const game = await response.json();
            await offlineDb.games
              .where('localId')
              .equals(request.id)
              .modify({ ...game, syncStatus: 'synced' });
          }
        }
      } catch (error) {
        console.error('Sync failed:', error);
      }
    }
  }
}
```

### 3. ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ•ãƒƒã‚¯

**src/hooks/useOffline.ts:**
```typescript
export const useOffline = () => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [pendingCount, setPendingCount] = useState(0);

  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¾©å¸°æ™‚ã«åŒæœŸ
      OfflineManager.syncPendingRequests();
    };

    const handleOffline = () => {
      setIsOnline(false);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // ãƒšãƒ³ãƒ‡ã‚£ãƒ³ã‚°æ•°ã‚’ç›£è¦–
    const interval = setInterval(async () => {
      const count = await offlineDb.pendingRequests.count();
      setPendingCount(count);
    }, 5000);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      clearInterval(interval);
    };
  }, []);

  return { isOnline, pendingCount };
};
```

### 4. ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œã‚µãƒ¼ãƒ“ã‚¹

**src/services/offlineGameService.ts:**
```typescript
export class OfflineGameService {
  static async getGames(teamId: number): Promise<Game[]> {
    if (navigator.onLine) {
      try {
        const games = await gameService.getGames(teamId);
        // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚ã¯IndexedDBã‚’æ›´æ–°
        await offlineDb.games.clear();
        await offlineDb.games.bulkAdd(games.map(g => ({
          ...g,
          syncStatus: 'synced' as const
        })));
        return games;
      } catch (error) {
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
        return offlineDb.games.where('teamId').equals(teamId).toArray();
      }
    } else {
      // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã¯IndexedDBã‹ã‚‰å–å¾—
      return offlineDb.games.where('teamId').equals(teamId).toArray();
    }
  }

  static async createGame(data: CreateGameDto): Promise<Game | string> {
    if (navigator.onLine) {
      try {
        return await gameService.createGame(data);
      } catch (error) {
        // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã ãŒå¤±æ•—ã—ãŸå ´åˆ
        return OfflineManager.savePendingGame(data);
      }
    } else {
      // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã¯ä¿ç•™
      return OfflineManager.savePendingGame(data);
    }
  }
}
```

### 5. ã‚ªãƒ•ãƒ©ã‚¤ãƒ³è¡¨ç¤ºã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

**src/components/common/OfflineIndicator.tsx:**
```typescript
export const OfflineIndicator: React.FC = () => {
  const { isOnline, pendingCount } = useOffline();

  if (isOnline && pendingCount === 0) {
    return null;
  }

  return (
    <div className={`offline-indicator ${!isOnline ? 'offline' : 'syncing'}`}>
      {!isOnline ? (
        <>
          <WifiOff size={16} />
          <span>ã‚ªãƒ•ãƒ©ã‚¤ãƒ³</span>
        </>
      ) : pendingCount > 0 ? (
        <>
          <RefreshCw size={16} className="spinning" />
          <span>åŒæœŸä¸­ ({pendingCount}ä»¶)</span>
        </>
      ) : null}
    </div>
  );
};
```

### 6. Service Workerç™»éŒ²

**src/serviceWorkerRegistration.ts:**
```typescript
export const register = async () => {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register(
        '/service-worker.js'
      );
      
      console.log('Service Worker registered:', registration);

      // æ›´æ–°ãƒã‚§ãƒƒã‚¯
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        if (newWorker) {
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'activated') {
              window.location.reload();
            }
          });
        }
      });
    } catch (error) {
      console.error('Service Worker registration failed:', error);
    }
  }
};
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã®æ“ä½œãŒä¿ç•™ã•ã‚Œã‚‹
- [ ] ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¾©å¸°æ™‚ã«è‡ªå‹•åŒæœŸã•ã‚Œã‚‹
- [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ãŒè¡¨ç¤ºã•ã‚Œã‚‹
- [ ] Service WorkerãŒæ­£ã—ãå‹•ä½œã™ã‚‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- Service Worker
- IndexedDB (Dexie)
- Background Sync API
- Cache API

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
8æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P4-001: Dashboard.tsxãƒªãƒ•ã‚¡ã‚¯ã‚¿
- P4-003: React Queryçµ±åˆ

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

```typescript
describe('Offline Support', () => {
  it('should save data to IndexedDB when offline', async () => {
    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: false
    });

    const gameData = { title: 'Test Game' };
    const result = await OfflineGameService.createGame(gameData);
    
    expect(result).toContain('local-');
    
    const pending = await offlineDb.pendingRequests.toArray();
    expect(pending).toHaveLength(1);
  });

  it('should sync when coming back online', async () => {
    // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã«æˆ»ã‚‹
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: true
    });

    window.dispatchEvent(new Event('online'));
    
    await waitFor(() => {
      expect(offlineDb.pendingRequests.count()).resolves.toBe(0);
    });
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§
- ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡åˆ¶é™
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆHTTPSãŒå¿…è¦ï¼‰

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`offline`, `pwa`, `service-worker`, `phase4`

## ğŸ“… ä½œæˆæ—¥
2025-09-08