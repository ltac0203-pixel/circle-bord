# ãƒã‚±ãƒƒãƒˆ P1-005: CRUD APIå®Ÿè£…

## ğŸ“‹ æ¦‚è¦
å„Entityã«å¯¾ã™ã‚‹åŸºæœ¬çš„ãªCRUDï¼ˆCreate, Read, Update, Deleteï¼‰æ“ä½œã‚’è¡Œã†RESTful APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- Repositoryå±¤ã®å®Ÿè£…
- Serviceå±¤ã®å®Ÿè£…
- Controllerå±¤ã®å®Ÿè£…
- ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°è¨­å®š
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

## ğŸ“ è©³ç´°èª¬æ˜

### 1. Repositoryå±¤å®Ÿè£…

**src/repositories/BaseRepository.ts:**
```typescript
import { Repository, EntityTarget, DataSource, FindManyOptions, FindOneOptions } from 'typeorm';

export class BaseRepository<T> {
  protected repository: Repository<T>;

  constructor(
    private dataSource: DataSource,
    private entity: EntityTarget<T>
  ) {
    this.repository = this.dataSource.getRepository(entity);
  }

  async findAll(options?: FindManyOptions<T>): Promise<T[]> {
    return this.repository.find(options);
  }

  async findOne(options: FindOneOptions<T>): Promise<T | null> {
    return this.repository.findOne(options);
  }

  async findById(id: string | number): Promise<T | null> {
    return this.repository.findOne({ where: { id } as any });
  }

  async create(data: Partial<T>): Promise<T> {
    const entity = this.repository.create(data);
    return this.repository.save(entity);
  }

  async update(id: string | number, data: Partial<T>): Promise<T> {
    await this.repository.update(id, data as any);
    const updated = await this.findById(id);
    if (!updated) {
      throw new Error('Entity not found after update');
    }
    return updated;
  }

  async delete(id: string | number): Promise<void> {
    await this.repository.delete(id);
  }

  async count(options?: FindManyOptions<T>): Promise<number> {
    return this.repository.count(options);
  }
}
```

**src/repositories/UserRepository.ts:**
```typescript
import { DataSource } from 'typeorm';
import { BaseRepository } from './BaseRepository';
import { User } from '../entities/User';

export class UserRepository extends BaseRepository<User> {
  constructor(dataSource: DataSource) {
    super(dataSource, User);
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.repository.findOne({ where: { email } });
  }

  async findWithTeams(userId: string): Promise<User | null> {
    return this.repository.findOne({
      where: { id: userId },
      relations: ['userTeams', 'userTeams.team']
    });
  }
}
```

**src/repositories/TeamRepository.ts:**
```typescript
import { DataSource } from 'typeorm';
import { BaseRepository } from './BaseRepository';
import { Team } from '../entities/Team';

export class TeamRepository extends BaseRepository<Team> {
  constructor(dataSource: DataSource) {
    super(dataSource, Team);
  }

  async findByName(name: string): Promise<Team | null> {
    return this.repository.findOne({ where: { name } });
  }

  async findWithMembers(teamId: number): Promise<Team | null> {
    return this.repository.findOne({
      where: { id: teamId },
      relations: ['userTeams', 'userTeams.user']
    });
  }
}
```

### 2. Serviceå±¤å®Ÿè£…

**src/services/UserService.ts:**
```typescript
import { UserRepository } from '../repositories/UserRepository';
import { User } from '../entities/User';
import { CreateUserDto, UpdateUserDto } from '../dtos/user.dto';
import { ConflictError, NotFoundError } from '../errors/AppError';

export class UserService {
  constructor(private userRepository: UserRepository) {}

  async getAllUsers(page = 1, limit = 10): Promise<{
    data: User[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const skip = (page - 1) * limit;
    const [data, total] = await Promise.all([
      this.userRepository.findAll({
        skip,
        take: limit,
        order: { createdAt: 'DESC' }
      }),
      this.userRepository.count()
    ]);

    return {
      data,
      total,
      page,
      totalPages: Math.ceil(total / limit)
    };
  }

  async getUserById(id: string): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new NotFoundError('User not found');
    }
    return user;
  }

  async createUser(data: CreateUserDto): Promise<User> {
    const existing = await this.userRepository.findByEmail(data.email);
    if (existing) {
      throw new ConflictError('Email already exists');
    }
    return this.userRepository.create(data);
  }

  async updateUser(id: string, data: UpdateUserDto): Promise<User> {
    const user = await this.getUserById(id);
    
    if (data.email && data.email !== user.email) {
      const existing = await this.userRepository.findByEmail(data.email);
      if (existing) {
        throw new ConflictError('Email already exists');
      }
    }
    
    return this.userRepository.update(id, data);
  }

  async deleteUser(id: string): Promise<void> {
    await this.getUserById(id);
    await this.userRepository.delete(id);
  }
}
```

**src/services/GameService.ts:**
```typescript
import { GameRepository } from '../repositories/GameRepository';
import { Game, GameStatus } from '../entities/Game';
import { CreateGameDto, UpdateGameDto, GameFilterDto } from '../dtos/game.dto';
import { NotFoundError } from '../errors/AppError';

export class GameService {
  constructor(private gameRepository: GameRepository) {}

  async searchGames(filters: GameFilterDto): Promise<Game[]> {
    const queryBuilder = this.gameRepository.createQueryBuilder('game')
      .leftJoinAndSelect('game.team', 'team')
      .leftJoinAndSelect('game.sport', 'sport')
      .leftJoinAndSelect('game.location', 'location');

    if (filters.sportId) {
      queryBuilder.andWhere('game.sportId = :sportId', { sportId: filters.sportId });
    }

    if (filters.locationId) {
      queryBuilder.andWhere('game.locationId = :locationId', { locationId: filters.locationId });
    }

    if (filters.date) {
      queryBuilder.andWhere('game.date = :date', { date: filters.date });
    }

    if (filters.status) {
      queryBuilder.andWhere('game.status = :status', { status: filters.status });
    } else {
      queryBuilder.andWhere('game.status = :status', { status: GameStatus.OPEN });
    }

    queryBuilder.orderBy('game.date', 'ASC')
      .addOrderBy('game.startTime', 'ASC');

    return queryBuilder.getMany();
  }

  async createGame(userId: string, teamId: number, data: CreateGameDto): Promise<Game> {
    // ãƒãƒ¼ãƒ æ‰€å±ç¢ºèªãƒ­ã‚¸ãƒƒã‚¯
    const gameData = {
      ...data,
      teamId,
      createdById: userId
    };
    
    return this.gameRepository.create(gameData);
  }

  async updateGameStatus(gameId: number, status: GameStatus): Promise<Game> {
    const game = await this.gameRepository.findById(gameId);
    if (!game) {
      throw new NotFoundError('Game not found');
    }
    
    game.status = status;
    return this.gameRepository.save(game);
  }
}
```

### 3. Controllerå±¤å®Ÿè£…

**src/controllers/UserController.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { UserService } from '../services/UserService';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';
import { CreateUserDto, UpdateUserDto } from '../dtos/user.dto';

export class UserController {
  constructor(private userService: UserService) {}

  async getAll = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      
      const result = await this.userService.getAllUsers(page, limit);
      res.json(result);
    } catch (error) {
      next(error);
    }
  };

  async getById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = await this.userService.getUserById(req.params.id);
      res.json(user);
    } catch (error) {
      next(error);
    }
  };

  async create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const dto = plainToClass(CreateUserDto, req.body);
      const errors = await validate(dto);
      
      if (errors.length > 0) {
        return res.status(400).json({ errors });
      }
      
      const user = await this.userService.createUser(dto);
      res.status(201).json(user);
    } catch (error) {
      next(error);
    }
  };

  async update = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const dto = plainToClass(UpdateUserDto, req.body);
      const errors = await validate(dto);
      
      if (errors.length > 0) {
        return res.status(400).json({ errors });
      }
      
      const user = await this.userService.updateUser(req.params.id, dto);
      res.json(user);
    } catch (error) {
      next(error);
    }
  };

  async delete = async (req: Request, res: Response, next: NextFunction) => {
    try {
      await this.userService.deleteUser(req.params.id);
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  };
}
```

### 4. ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°è¨­å®š

**src/routes/userRoutes.ts:**
```typescript
import { Router } from 'express';
import { UserController } from '../controllers/UserController';
import { UserService } from '../services/UserService';
import { UserRepository } from '../repositories/UserRepository';
import { AppDataSource } from '../config/database';
import { authenticate } from '../middlewares/auth';

const router = Router();

const userRepository = new UserRepository(AppDataSource);
const userService = new UserService(userRepository);
const userController = new UserController(userService);

router.get('/', authenticate, userController.getAll);
router.get('/:id', authenticate, userController.getById);
router.post('/', userController.create);
router.put('/:id', authenticate, userController.update);
router.delete('/:id', authenticate, userController.delete);

export default router;
```

**src/routes/index.ts:**
```typescript
import { Router } from 'express';
import userRoutes from './userRoutes';
import teamRoutes from './teamRoutes';
import gameRoutes from './gameRoutes';
import matchRoutes from './matchRoutes';
import sportRoutes from './sportRoutes';
import locationRoutes from './locationRoutes';

const router = Router();

router.use('/users', userRoutes);
router.use('/teams', teamRoutes);
router.use('/games', gameRoutes);
router.use('/matches', matchRoutes);
router.use('/sports', sportRoutes);
router.use('/locations', locationRoutes);

export default router;
```

### 5. DTOã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

**src/dtos/user.dto.ts:**
```typescript
import { IsEmail, IsNotEmpty, MinLength, IsOptional } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @MinLength(6)
  password: string;

  @IsNotEmpty()
  name: string;
}

export class UpdateUserDto {
  @IsOptional()
  @IsEmail()
  email?: string;

  @IsOptional()
  @IsNotEmpty()
  name?: string;
}
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ã™ã¹ã¦ã®Entityã«å¯¾ã™ã‚‹CRUD APIãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] Repositoryå±¤ãŒé©åˆ‡ã«æŠ½è±¡åŒ–ã•ã‚Œã¦ã„ã‚‹
- [ ] Serviceå±¤ã§ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] Controllerå±¤ã§HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå‡¦ç†ã•ã‚Œã‚‹
- [ ] ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãŒæ©Ÿèƒ½ã—ã¦ã„ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- Express.js
- TypeORM Repository
- class-validator
- class-transformer

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
16æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P1-004: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Œäº†å¿…é ˆï¼‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

### API ãƒ†ã‚¹ãƒˆï¼ˆPostman/curlï¼‰
```bash
# ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½œæˆ
curl -X POST http://localhost:3001/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "name": "Test User"
  }'

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§å–å¾—
curl http://localhost:3001/api/users?page=1&limit=10

# ãƒ¦ãƒ¼ã‚¶ãƒ¼è©³ç´°å–å¾—
curl http://localhost:3001/api/users/{userId}

# ãƒ¦ãƒ¼ã‚¶ãƒ¼æ›´æ–°
curl -X PUT http://localhost:3001/api/users/{userId} \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Updated Name"
  }'

# ãƒ¦ãƒ¼ã‚¶ãƒ¼å‰Šé™¤
curl -X DELETE http://localhost:3001/api/users/{userId}
```

## ğŸ“Œ æ³¨æ„äº‹é …

- SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ã‚’å®Ÿæ–½
- N+1å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚é©åˆ‡ã«ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰æ©Ÿå¯†æƒ…å ±ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç­‰ï¼‰ã‚’é™¤å¤–
- é©åˆ‡ãªHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™
- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’é©åˆ‡ã«å®Ÿè£…

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`api`, `crud`, `backend`, `phase1`

## ğŸ“… ä½œæˆæ—¥
2025-09-08