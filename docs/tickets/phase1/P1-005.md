# チケット P1-005: CRUD API実装

## 📋 概要
各Entityに対する基本的なCRUD（Create, Read, Update, Delete）操作を行うRESTful APIエンドポイントを実装する。

## 🎯 目標
- Repository層の実装
- Service層の実装
- Controller層の実装
- ルーティング設定
- エラーハンドリング

## 📝 詳細説明

### 1. Repository層実装

**src/repositories/BaseRepository.ts:**
```typescript
import { Repository, EntityTarget, DataSource, FindManyOptions, FindOneOptions } from 'typeorm';

export class BaseRepository<T> {
  protected repository: Repository<T>;

  constructor(
    private dataSource: DataSource,
    private entity: EntityTarget<T>
  ) {
    this.repository = this.dataSource.getRepository(entity);
  }

  async findAll(options?: FindManyOptions<T>): Promise<T[]> {
    return this.repository.find(options);
  }

  async findOne(options: FindOneOptions<T>): Promise<T | null> {
    return this.repository.findOne(options);
  }

  async findById(id: string | number): Promise<T | null> {
    return this.repository.findOne({ where: { id } as any });
  }

  async create(data: Partial<T>): Promise<T> {
    const entity = this.repository.create(data);
    return this.repository.save(entity);
  }

  async update(id: string | number, data: Partial<T>): Promise<T> {
    await this.repository.update(id, data as any);
    const updated = await this.findById(id);
    if (!updated) {
      throw new Error('Entity not found after update');
    }
    return updated;
  }

  async delete(id: string | number): Promise<void> {
    await this.repository.delete(id);
  }

  async count(options?: FindManyOptions<T>): Promise<number> {
    return this.repository.count(options);
  }
}
```

**src/repositories/UserRepository.ts:**
```typescript
import { DataSource } from 'typeorm';
import { BaseRepository } from './BaseRepository';
import { User } from '../entities/User';

export class UserRepository extends BaseRepository<User> {
  constructor(dataSource: DataSource) {
    super(dataSource, User);
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.repository.findOne({ where: { email } });
  }

  async findWithTeams(userId: string): Promise<User | null> {
    return this.repository.findOne({
      where: { id: userId },
      relations: ['userTeams', 'userTeams.team']
    });
  }
}
```

**src/repositories/TeamRepository.ts:**
```typescript
import { DataSource } from 'typeorm';
import { BaseRepository } from './BaseRepository';
import { Team } from '../entities/Team';

export class TeamRepository extends BaseRepository<Team> {
  constructor(dataSource: DataSource) {
    super(dataSource, Team);
  }

  async findByName(name: string): Promise<Team | null> {
    return this.repository.findOne({ where: { name } });
  }

  async findWithMembers(teamId: number): Promise<Team | null> {
    return this.repository.findOne({
      where: { id: teamId },
      relations: ['userTeams', 'userTeams.user']
    });
  }
}
```

### 2. Service層実装

**src/services/UserService.ts:**
```typescript
import { UserRepository } from '../repositories/UserRepository';
import { User } from '../entities/User';
import { CreateUserDto, UpdateUserDto } from '../dtos/user.dto';
import { ConflictError, NotFoundError } from '../errors/AppError';

export class UserService {
  constructor(private userRepository: UserRepository) {}

  async getAllUsers(page = 1, limit = 10): Promise<{
    data: User[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const skip = (page - 1) * limit;
    const [data, total] = await Promise.all([
      this.userRepository.findAll({
        skip,
        take: limit,
        order: { createdAt: 'DESC' }
      }),
      this.userRepository.count()
    ]);

    return {
      data,
      total,
      page,
      totalPages: Math.ceil(total / limit)
    };
  }

  async getUserById(id: string): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new NotFoundError('User not found');
    }
    return user;
  }

  async createUser(data: CreateUserDto): Promise<User> {
    const existing = await this.userRepository.findByEmail(data.email);
    if (existing) {
      throw new ConflictError('Email already exists');
    }
    return this.userRepository.create(data);
  }

  async updateUser(id: string, data: UpdateUserDto): Promise<User> {
    const user = await this.getUserById(id);
    
    if (data.email && data.email !== user.email) {
      const existing = await this.userRepository.findByEmail(data.email);
      if (existing) {
        throw new ConflictError('Email already exists');
      }
    }
    
    return this.userRepository.update(id, data);
  }

  async deleteUser(id: string): Promise<void> {
    await this.getUserById(id);
    await this.userRepository.delete(id);
  }
}
```

**src/services/GameService.ts:**
```typescript
import { GameRepository } from '../repositories/GameRepository';
import { Game, GameStatus } from '../entities/Game';
import { CreateGameDto, UpdateGameDto, GameFilterDto } from '../dtos/game.dto';
import { NotFoundError } from '../errors/AppError';

export class GameService {
  constructor(private gameRepository: GameRepository) {}

  async searchGames(filters: GameFilterDto): Promise<Game[]> {
    const queryBuilder = this.gameRepository.createQueryBuilder('game')
      .leftJoinAndSelect('game.team', 'team')
      .leftJoinAndSelect('game.sport', 'sport')
      .leftJoinAndSelect('game.location', 'location');

    if (filters.sportId) {
      queryBuilder.andWhere('game.sportId = :sportId', { sportId: filters.sportId });
    }

    if (filters.locationId) {
      queryBuilder.andWhere('game.locationId = :locationId', { locationId: filters.locationId });
    }

    if (filters.date) {
      queryBuilder.andWhere('game.date = :date', { date: filters.date });
    }

    if (filters.status) {
      queryBuilder.andWhere('game.status = :status', { status: filters.status });
    } else {
      queryBuilder.andWhere('game.status = :status', { status: GameStatus.OPEN });
    }

    queryBuilder.orderBy('game.date', 'ASC')
      .addOrderBy('game.startTime', 'ASC');

    return queryBuilder.getMany();
  }

  async createGame(userId: string, teamId: number, data: CreateGameDto): Promise<Game> {
    // チーム所属確認ロジック
    const gameData = {
      ...data,
      teamId,
      createdById: userId
    };
    
    return this.gameRepository.create(gameData);
  }

  async updateGameStatus(gameId: number, status: GameStatus): Promise<Game> {
    const game = await this.gameRepository.findById(gameId);
    if (!game) {
      throw new NotFoundError('Game not found');
    }
    
    game.status = status;
    return this.gameRepository.save(game);
  }
}
```

### 3. Controller層実装

**src/controllers/UserController.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { UserService } from '../services/UserService';
import { validate } from 'class-validator';
import { plainToClass } from 'class-transformer';
import { CreateUserDto, UpdateUserDto } from '../dtos/user.dto';

export class UserController {
  constructor(private userService: UserService) {}

  async getAll = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      
      const result = await this.userService.getAllUsers(page, limit);
      res.json(result);
    } catch (error) {
      next(error);
    }
  };

  async getById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = await this.userService.getUserById(req.params.id);
      res.json(user);
    } catch (error) {
      next(error);
    }
  };

  async create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const dto = plainToClass(CreateUserDto, req.body);
      const errors = await validate(dto);
      
      if (errors.length > 0) {
        return res.status(400).json({ errors });
      }
      
      const user = await this.userService.createUser(dto);
      res.status(201).json(user);
    } catch (error) {
      next(error);
    }
  };

  async update = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const dto = plainToClass(UpdateUserDto, req.body);
      const errors = await validate(dto);
      
      if (errors.length > 0) {
        return res.status(400).json({ errors });
      }
      
      const user = await this.userService.updateUser(req.params.id, dto);
      res.json(user);
    } catch (error) {
      next(error);
    }
  };

  async delete = async (req: Request, res: Response, next: NextFunction) => {
    try {
      await this.userService.deleteUser(req.params.id);
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  };
}
```

### 4. ルーティング設定

**src/routes/userRoutes.ts:**
```typescript
import { Router } from 'express';
import { UserController } from '../controllers/UserController';
import { UserService } from '../services/UserService';
import { UserRepository } from '../repositories/UserRepository';
import { AppDataSource } from '../config/database';
import { authenticate } from '../middlewares/auth';

const router = Router();

const userRepository = new UserRepository(AppDataSource);
const userService = new UserService(userRepository);
const userController = new UserController(userService);

router.get('/', authenticate, userController.getAll);
router.get('/:id', authenticate, userController.getById);
router.post('/', userController.create);
router.put('/:id', authenticate, userController.update);
router.delete('/:id', authenticate, userController.delete);

export default router;
```

**src/routes/index.ts:**
```typescript
import { Router } from 'express';
import userRoutes from './userRoutes';
import teamRoutes from './teamRoutes';
import gameRoutes from './gameRoutes';
import matchRoutes from './matchRoutes';
import sportRoutes from './sportRoutes';
import locationRoutes from './locationRoutes';

const router = Router();

router.use('/users', userRoutes);
router.use('/teams', teamRoutes);
router.use('/games', gameRoutes);
router.use('/matches', matchRoutes);
router.use('/sports', sportRoutes);
router.use('/locations', locationRoutes);

export default router;
```

### 5. DTOとバリデーション

**src/dtos/user.dto.ts:**
```typescript
import { IsEmail, IsNotEmpty, MinLength, IsOptional } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @MinLength(6)
  password: string;

  @IsNotEmpty()
  name: string;
}

export class UpdateUserDto {
  @IsOptional()
  @IsEmail()
  email?: string;

  @IsOptional()
  @IsNotEmpty()
  name?: string;
}
```

## ✅ 受け入れ条件

- [ ] すべてのEntityに対するCRUD APIが実装されている
- [ ] Repository層が適切に抽象化されている
- [ ] Service層でビジネスロジックが実装されている
- [ ] Controller層でHTTPリクエスト/レスポンスが処理される
- [ ] バリデーションが機能している
- [ ] エラーハンドリングが実装されている
- [ ] ページネーションが実装されている

## 🔧 技術要件

- Express.js
- TypeORM Repository
- class-validator
- class-transformer

## ⏱️ 見積もり時間
16時間

## 🔗 依存関係
- P1-004: データベースマイグレーション（完了必須）

## 🧪 テスト方針

### API テスト（Postman/curl）
```bash
# ユーザー作成
curl -X POST http://localhost:3001/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "name": "Test User"
  }'

# ユーザー一覧取得
curl http://localhost:3001/api/users?page=1&limit=10

# ユーザー詳細取得
curl http://localhost:3001/api/users/{userId}

# ユーザー更新
curl -X PUT http://localhost:3001/api/users/{userId} \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Updated Name"
  }'

# ユーザー削除
curl -X DELETE http://localhost:3001/api/users/{userId}
```

## 📌 注意事項

- SQLインジェクション対策を実施
- N+1問題を避けるため適切にリレーションをロード
- レスポンスから機密情報（パスワード等）を除外
- 適切なHTTPステータスコードを返す
- トランザクション処理を適切に実装

## 🏷️ ラベル
`api`, `crud`, `backend`, `phase1`

## 📅 作成日
2025-09-08