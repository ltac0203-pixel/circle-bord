# ãƒã‚±ãƒƒãƒˆ P1-003: Entityå®šç¾©å®Ÿè£…

## ğŸ“‹ æ¦‚è¦
TypeORMã‚’ä½¿ç”¨ã—ã¦ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®Entityï¼ˆã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ï¼‰ã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã€ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- ã™ã¹ã¦ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾å¿œã™ã‚‹Entityã‚¯ãƒ©ã‚¹ã®ä½œæˆ
- ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—ã®å®šç¾©
- ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«ã®å®Ÿè£…
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®è¨­å®š

## ğŸ“ è©³ç´°èª¬æ˜

### 1. User Entity

**src/entities/User.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany, BeforeInsert } from 'typeorm';
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';
import * as bcrypt from 'bcrypt';
import { UserTeam } from './UserTeam';
import { Game } from './Game';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  @IsEmail()
  email: string;

  @Column()
  @MinLength(6)
  password: string;

  @Column({ length: 100 })
  @IsNotEmpty()
  name: string;

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relations
  @OneToMany(() => UserTeam, userTeam => userTeam.user)
  userTeams: UserTeam[];

  @OneToMany(() => Game, game => game.createdBy)
  createdGames: Game[];

  // Hooks
  @BeforeInsert()
  async hashPassword() {
    if (this.password) {
      this.password = await bcrypt.hash(this.password, 10);
    }
  }

  async validatePassword(password: string): Promise<boolean> {
    return bcrypt.compare(password, this.password);
  }
}
```

### 2. Team Entity

**src/entities/Team.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, OneToMany, JoinColumn } from 'typeorm';
import { IsNotEmpty, IsEmail, IsOptional } from 'class-validator';
import { User } from './User';
import { UserTeam } from './UserTeam';
import { Game } from './Game';

@Entity('teams')
export class Team {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, length: 100 })
  @IsNotEmpty()
  name: string;

  @Column({ length: 100, nullable: true })
  @IsOptional()
  university?: string;

  @Column({ nullable: true })
  @IsEmail()
  @IsOptional()
  contactEmail?: string;

  @Column('text', { nullable: true })
  @IsOptional()
  description?: string;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ nullable: true })
  createdById: string;

  // Relations
  @ManyToOne(() => User, { nullable: true })
  @JoinColumn({ name: 'createdById' })
  createdBy?: User;

  @OneToMany(() => UserTeam, userTeam => userTeam.team)
  userTeams: UserTeam[];

  @OneToMany(() => Game, game => game.team)
  games: Game[];
}
```

### 3. UserTeam Entity (Junction Table)

**src/entities/UserTeam.ts:**
```typescript
import { Entity, PrimaryColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';
import { Team } from './Team';

export enum TeamRole {
  ADMIN = 'admin',
  CAPTAIN = 'captain',
  MEMBER = 'member'
}

@Entity('user_teams')
export class UserTeam {
  @PrimaryColumn()
  userId: string;

  @PrimaryColumn()
  teamId: number;

  @Column({
    type: 'enum',
    enum: TeamRole,
    default: TeamRole.MEMBER
  })
  role: TeamRole;

  @CreateDateColumn()
  joinedAt: Date;

  // Relations
  @ManyToOne(() => User, user => user.userTeams, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'userId' })
  user: User;

  @ManyToOne(() => Team, team => team.userTeams, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'teamId' })
  team: Team;
}
```

### 4. Sport Entity

**src/entities/Sport.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from 'typeorm';
import { IsNotEmpty } from 'class-validator';
import { Game } from './Game';

@Entity('sports')
export class Sport {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, length: 50 })
  @IsNotEmpty()
  name: string;

  @Column({ length: 50, nullable: true })
  category?: string;

  @Column({ default: true })
  isActive: boolean;

  // Relations
  @OneToMany(() => Game, game => game.sport)
  games: Game[];
}
```

### 5. Location Entity

**src/entities/Location.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, OneToMany } from 'typeorm';
import { IsNotEmpty } from 'class-validator';
import { Game } from './Game';

@Entity('locations')
export class Location {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  @IsNotEmpty()
  name: string;

  @Column('text', { nullable: true })
  address?: string;

  @Column({ length: 20, nullable: true })
  prefecture?: string;

  @Column({ length: 50, nullable: true })
  city?: string;

  @CreateDateColumn()
  createdAt: Date;

  // Relations
  @OneToMany(() => Game, game => game.location)
  games: Game[];
}
```

### 6. Game Entity

**src/entities/Game.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, OneToMany, JoinColumn, Index } from 'typeorm';
import { IsNotEmpty, IsDateString, IsOptional, Min } from 'class-validator';
import { Team } from './Team';
import { Sport } from './Sport';
import { Location } from './Location';
import { User } from './User';
import { Match } from './Match';

export enum GameStatus {
  OPEN = 'open',
  MATCHED = 'matched',
  COMPLETED = 'completed',
  CANCELLED = 'cancelled'
}

@Entity('games')
@Index(['date', 'sportId'])
@Index(['status'])
@Index(['teamId'])
export class Game {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  teamId: number;

  @Column()
  sportId: number;

  @Column()
  locationId: number;

  @Column('date')
  @IsDateString()
  date: string;

  @Column('time')
  @IsNotEmpty()
  startTime: string;

  @Column('time', { nullable: true })
  endTime?: string;

  @Column({ nullable: true })
  contact?: string;

  @Column('text', { nullable: true })
  description?: string;

  @Column({
    type: 'enum',
    enum: GameStatus,
    default: GameStatus.OPEN
  })
  status: GameStatus;

  @Column({ nullable: true })
  @Min(1)
  @IsOptional()
  maxParticipants?: number;

  @CreateDateColumn()
  createdAt: Date;

  @Column({ nullable: true })
  createdById: string;

  // Relations
  @ManyToOne(() => Team, team => team.games, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'teamId' })
  team: Team;

  @ManyToOne(() => Sport, sport => sport.games)
  @JoinColumn({ name: 'sportId' })
  sport: Sport;

  @ManyToOne(() => Location, location => location.games)
  @JoinColumn({ name: 'locationId' })
  location: Location;

  @ManyToOne(() => User, user => user.createdGames)
  @JoinColumn({ name: 'createdById' })
  createdBy: User;

  @OneToMany(() => Match, match => match.game1)
  matchesAsGame1: Match[];

  @OneToMany(() => Match, match => match.game2)
  matchesAsGame2: Match[];
}
```

### 7. Match Entity

**src/entities/Match.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, OneToMany, JoinColumn, Unique, Check } from 'typeorm';
import { Game } from './Game';
import { MatchCommunication } from './MatchCommunication';

export enum MatchStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  CANCELLED = 'cancelled',
  COMPLETED = 'completed'
}

@Entity('matches')
@Unique(['game1Id', 'game2Id'])
@Check('"game1Id" != "game2Id"')
export class Match {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  game1Id: number;

  @Column()
  game2Id: number;

  @CreateDateColumn()
  matchedAt: Date;

  @Column({
    type: 'enum',
    enum: MatchStatus,
    default: MatchStatus.PENDING
  })
  status: MatchStatus;

  @Column('json', { nullable: true })
  result?: {
    team1Score?: number;
    team2Score?: number;
    [key: string]: any;
  };

  @Column('text', { nullable: true })
  notes?: string;

  // Relations
  @ManyToOne(() => Game, game => game.matchesAsGame1, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'game1Id' })
  game1: Game;

  @ManyToOne(() => Game, game => game.matchesAsGame2, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'game2Id' })
  game2: Game;

  @OneToMany(() => MatchCommunication, comm => comm.match)
  communications: MatchCommunication[];
}
```

### 8. MatchCommunication Entity

**src/entities/MatchCommunication.ts:**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { IsNotEmpty } from 'class-validator';
import { Match } from './Match';
import { User } from './User';

@Entity('match_communications')
export class MatchCommunication {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  matchId: number;

  @Column()
  senderId: string;

  @Column('text')
  @IsNotEmpty()
  message: string;

  @CreateDateColumn()
  sentAt: Date;

  @Column({ default: false })
  isRead: boolean;

  // Relations
  @ManyToOne(() => Match, match => match.communications, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'matchId' })
  match: Match;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'senderId' })
  sender: User;
}
```

### 9. Entity Index File

**src/entities/index.ts:**
```typescript
export { User } from './User';
export { Team } from './Team';
export { UserTeam, TeamRole } from './UserTeam';
export { Sport } from './Sport';
export { Location } from './Location';
export { Game, GameStatus } from './Game';
export { Match, MatchStatus } from './Match';
export { MatchCommunication } from './MatchCommunication';
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] ã™ã¹ã¦ã®Entityã‚¯ãƒ©ã‚¹ãŒä½œæˆã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—ãŒæ­£ã—ãå®šç¾©ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé©åˆ‡ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] TypeScriptã®å‹å®šç¾©ãŒæ­£ã—ã„
- [ ] ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã®ãƒãƒƒã‚·ãƒ¥åŒ–ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] EnumãŒé©åˆ‡ã«å®šç¾©ã•ã‚Œã¦ã„ã‚‹

## ğŸ”§ æŠ€è¡“è¦ä»¶

- TypeORM 0.3.x
- class-validator
- bcryptï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–ï¼‰
- UUID v4ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼‰

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
16æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P1-002: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–ï¼ˆå®Œäº†å¿…é ˆï¼‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

### Entity ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
```typescript
import { validate } from 'class-validator';
import { User } from '../src/entities/User';

describe('User Entity', () => {
  it('should validate email format', async () => {
    const user = new User();
    user.email = 'invalid-email';
    user.name = 'Test User';
    user.password = 'password123';

    const errors = await validate(user);
    expect(errors.length).toBeGreaterThan(0);
  });

  it('should hash password before insert', async () => {
    const user = new User();
    user.password = 'plaintext';
    await user.hashPassword();
    
    expect(user.password).not.toBe('plaintext');
    expect(user.password.length).toBeGreaterThan(20);
  });
});
```

## ğŸ“Œ æ³¨æ„äº‹é …

- Entityã®å¤‰æ›´ã¯å¿…ãšãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨
- ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ãƒƒãƒ—ã®ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰è¨­å®šã«æ³¨æ„
- JSONã‚«ãƒ©ãƒ ã®ä½¿ç”¨ã¯æœ€å°é™ã«ç•™ã‚ã‚‹
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯æ¤œç´¢ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’è€ƒæ…®ã—ã¦è¨­å®š
- å¾ªç’°å‚ç…§ã«æ³¨æ„

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`entity`, `database`, `typeorm`, `phase1`

## ğŸ“… ä½œæˆæ—¥
2025-09-08