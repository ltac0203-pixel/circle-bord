# ãƒã‚±ãƒƒãƒˆ P1-007: å˜ä½“ãƒ†ã‚¹ãƒˆä½œæˆ

## ğŸ“‹ æ¦‚è¦
ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã®å˜ä½“ãƒ†ã‚¹ãƒˆã¨ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆã‚’ä½œæˆã—ã€ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’æ¸¬å®šã™ã‚‹ã€‚

## ğŸ¯ ç›®æ¨™
- Jestãƒ†ã‚¹ãƒˆç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- Repositoryå±¤ã®ãƒ†ã‚¹ãƒˆ
- Serviceå±¤ã®ãƒ†ã‚¹ãƒˆ
- Controllerå±¤ã®ãƒ†ã‚¹ãƒˆ
- APIã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
- 80%ä»¥ä¸Šã®ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸

## ğŸ“ è©³ç´°èª¬æ˜

### 1. ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

```bash
# ãƒ†ã‚¹ãƒˆé–¢é€£ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install -D jest @types/jest ts-jest
npm install -D supertest @types/supertest
npm install -D @faker-js/faker
npm install -D sqlite3  # ãƒ†ã‚¹ãƒˆç”¨ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªDB
```

**jest.config.js:**
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/migrations/**',
    '!src/seeds/**',
    '!src/server.ts'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  globals: {
    'ts-jest': {
      tsconfig: {
        experimentalDecorators: true,
        emitDecoratorMetadata: true
      }
    }
  }
};
```

### 2. ãƒ†ã‚¹ãƒˆç”¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š

**src/test/setup.ts:**
```typescript
import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from '../entities/User';
import { Team } from '../entities/Team';
import { UserTeam } from '../entities/UserTeam';
import { Sport } from '../entities/Sport';
import { Location } from '../entities/Location';
import { Game } from '../entities/Game';
import { Match } from '../entities/Match';
import { MatchCommunication } from '../entities/MatchCommunication';

export const TestDataSource = new DataSource({
  type: 'sqlite',
  database: ':memory:',
  dropSchema: true,
  entities: [
    User, Team, UserTeam, Sport, 
    Location, Game, Match, MatchCommunication
  ],
  synchronize: true,
  logging: false
});

beforeAll(async () => {
  await TestDataSource.initialize();
});

afterAll(async () => {
  await TestDataSource.destroy();
});

beforeEach(async () => {
  // ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¯ãƒªã‚¢
  const entities = TestDataSource.entityMetadatas;
  for (const entity of entities) {
    const repository = TestDataSource.getRepository(entity.name);
    await repository.clear();
  }
});
```

### 3. ãƒ†ã‚¹ãƒˆãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

**src/test/factories/userFactory.ts:**
```typescript
import { faker } from '@faker-js/faker';
import { User } from '../../entities/User';
import { TestDataSource } from '../setup';

export const createUser = async (overrides?: Partial<User>): Promise<User> => {
  const userRepository = TestDataSource.getRepository(User);
  
  const user = userRepository.create({
    email: faker.internet.email(),
    password: 'password123',
    name: faker.person.fullName(),
    isActive: true,
    ...overrides
  });
  
  return userRepository.save(user);
};
```

**src/test/factories/teamFactory.ts:**
```typescript
import { faker } from '@faker-js/faker';
import { Team } from '../../entities/Team';
import { TestDataSource } from '../setup';

export const createTeam = async (overrides?: Partial<Team>): Promise<Team> => {
  const teamRepository = TestDataSource.getRepository(Team);
  
  const team = teamRepository.create({
    name: faker.company.name(),
    university: faker.company.name() + 'å¤§å­¦',
    contactEmail: faker.internet.email(),
    description: faker.lorem.paragraph(),
    ...overrides
  });
  
  return teamRepository.save(team);
};
```

### 4. Repositoryå±¤ãƒ†ã‚¹ãƒˆ

**src/repositories/__tests__/UserRepository.test.ts:**
```typescript
import { UserRepository } from '../UserRepository';
import { TestDataSource } from '../../test/setup';
import { createUser } from '../../test/factories/userFactory';

describe('UserRepository', () => {
  let userRepository: UserRepository;

  beforeEach(() => {
    userRepository = new UserRepository(TestDataSource);
  });

  describe('findByEmail', () => {
    it('should find user by email', async () => {
      const user = await createUser({ email: 'test@example.com' });
      
      const found = await userRepository.findByEmail('test@example.com');
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(user.id);
      expect(found?.email).toBe('test@example.com');
    });

    it('should return null if user not found', async () => {
      const found = await userRepository.findByEmail('notfound@example.com');
      
      expect(found).toBeNull();
    });
  });

  describe('findWithTeams', () => {
    it('should find user with teams', async () => {
      const user = await createUser();
      // ãƒãƒ¼ãƒ é–¢é€£ã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ä½œæˆ
      
      const found = await userRepository.findWithTeams(user.id);
      
      expect(found).toBeDefined();
      expect(found?.userTeams).toBeDefined();
    });
  });
});
```

### 5. Serviceå±¤ãƒ†ã‚¹ãƒˆ

**src/services/__tests__/UserService.test.ts:**
```typescript
import { UserService } from '../UserService';
import { UserRepository } from '../../repositories/UserRepository';
import { TestDataSource } from '../../test/setup';
import { createUser } from '../../test/factories/userFactory';
import { ConflictError, NotFoundError } from '../../errors/AppError';

describe('UserService', () => {
  let userService: UserService;
  let userRepository: UserRepository;

  beforeEach(() => {
    userRepository = new UserRepository(TestDataSource);
    userService = new UserService(userRepository);
  });

  describe('getAllUsers', () => {
    it('should return paginated users', async () => {
      // 15äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ä½œæˆ
      for (let i = 0; i < 15; i++) {
        await createUser();
      }

      const result = await userService.getAllUsers(1, 10);

      expect(result.data).toHaveLength(10);
      expect(result.total).toBe(15);
      expect(result.page).toBe(1);
      expect(result.totalPages).toBe(2);
    });
  });

  describe('getUserById', () => {
    it('should return user by id', async () => {
      const user = await createUser();

      const found = await userService.getUserById(user.id);

      expect(found.id).toBe(user.id);
      expect(found.email).toBe(user.email);
    });

    it('should throw NotFoundError if user not found', async () => {
      await expect(userService.getUserById('invalid-id'))
        .rejects.toThrow(NotFoundError);
    });
  });

  describe('createUser', () => {
    it('should create new user', async () => {
      const userData = {
        email: 'new@example.com',
        password: 'password123',
        name: 'New User'
      };

      const user = await userService.createUser(userData);

      expect(user.email).toBe(userData.email);
      expect(user.name).toBe(userData.name);
      // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯ãƒãƒƒã‚·ãƒ¥åŒ–ã•ã‚Œã¦ã„ã‚‹
      expect(user.password).not.toBe(userData.password);
    });

    it('should throw ConflictError if email exists', async () => {
      await createUser({ email: 'existing@example.com' });

      await expect(userService.createUser({
        email: 'existing@example.com',
        password: 'password',
        name: 'Test'
      })).rejects.toThrow(ConflictError);
    });
  });
});
```

### 6. Controllerå±¤ãƒ†ã‚¹ãƒˆ

**src/controllers/__tests__/UserController.test.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { UserController } from '../UserController';
import { UserService } from '../../services/UserService';

describe('UserController', () => {
  let userController: UserController;
  let userService: jest.Mocked<UserService>;
  let req: Partial<Request>;
  let res: Partial<Response>;
  let next: NextFunction;

  beforeEach(() => {
    userService = {
      getAllUsers: jest.fn(),
      getUserById: jest.fn(),
      createUser: jest.fn(),
      updateUser: jest.fn(),
      deleteUser: jest.fn()
    } as any;

    userController = new UserController(userService);

    req = {
      query: {},
      params: {},
      body: {}
    };

    res = {
      json: jest.fn().mockReturnThis(),
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    next = jest.fn();
  });

  describe('getAll', () => {
    it('should return users with pagination', async () => {
      const mockResult = {
        data: [],
        total: 0,
        page: 1,
        totalPages: 0
      };

      userService.getAllUsers.mockResolvedValue(mockResult);
      req.query = { page: '1', limit: '10' };

      await userController.getAll(req as Request, res as Response, next);

      expect(userService.getAllUsers).toHaveBeenCalledWith(1, 10);
      expect(res.json).toHaveBeenCalledWith(mockResult);
    });

    it('should handle errors', async () => {
      const error = new Error('Test error');
      userService.getAllUsers.mockRejectedValue(error);

      await userController.getAll(req as Request, res as Response, next);

      expect(next).toHaveBeenCalledWith(error);
    });
  });
});
```

### 7. APIã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ

**src/__tests__/api.integration.test.ts:**
```typescript
import request from 'supertest';
import app from '../app';
import { TestDataSource } from '../test/setup';
import { createUser } from '../test/factories/userFactory';
import jwt from 'jsonwebtoken';

describe('API Integration Tests', () => {
  let authToken: string;

  beforeAll(async () => {
    // ãƒ†ã‚¹ãƒˆç”¨ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
    const user = await createUser();
    authToken = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'test-secret'
    );
  });

  describe('GET /api/users', () => {
    it('should require authentication', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect(401);

      expect(response.body.message).toBe('Authentication required');
    });

    it('should return users with valid token', async () => {
      await createUser();
      await createUser();

      const response = await request(app)
        .get('/api/users')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.data.length).toBeGreaterThan(0);
    });
  });

  describe('POST /api/users', () => {
    it('should create new user', async () => {
      const userData = {
        email: 'newuser@example.com',
        password: 'password123',
        name: 'New User'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);

      expect(response.body.email).toBe(userData.email);
      expect(response.body.name).toBe(userData.name);
      expect(response.body.password).toBeUndefined();
    });

    it('should validate request body', async () => {
      const invalidData = {
        email: 'invalid-email',
        password: '123',  // too short
        name: ''
      };

      const response = await request(app)
        .post('/api/users')
        .send(invalidData)
        .expect(400);

      expect(response.body.errors).toBeDefined();
    });
  });
});
```

### 8. package.jsonã‚¹ã‚¯ãƒªãƒ—ãƒˆæ›´æ–°

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:integration": "jest --testPathPattern=integration",
    "test:unit": "jest --testPathIgnorePatterns=integration"
  }
}
```

## âœ… å—ã‘å…¥ã‚Œæ¡ä»¶

- [ ] Jestç’°å¢ƒãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ†ã‚¹ãƒˆç”¨ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãŒå‹•ä½œã™ã‚‹
- [ ] Repositoryå±¤ã®ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] Serviceå±¤ã®ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] Controllerå±¤ã®ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] APIã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸ãŒ80%ä»¥ä¸Š
- [ ] CI/CDã§ãƒ†ã‚¹ãƒˆãŒè‡ªå‹•å®Ÿè¡Œã•ã‚Œã‚‹è¨­å®š

## ğŸ”§ æŠ€è¡“è¦ä»¶

- Jest
- Supertest
- TypeScriptå¯¾å¿œ
- SQLiteï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
- Faker.js

## â±ï¸ è¦‹ç©ã‚‚ã‚Šæ™‚é–“
12æ™‚é–“

## ğŸ”— ä¾å­˜é–¢ä¿‚
- P1-005: CRUD APIå®Ÿè£…ï¼ˆå®Œäº†å¿…é ˆï¼‰

## ğŸ§ª ãƒ†ã‚¹ãƒˆæ–¹é‡

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰
```bash
# å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
npm test

# ã‚«ãƒãƒ¬ãƒƒã‚¸ä»˜ããƒ†ã‚¹ãƒˆ
npm run test:coverage

# ã‚¦ã‚©ãƒƒãƒãƒ¢ãƒ¼ãƒ‰
npm run test:watch

# å˜ä½“ãƒ†ã‚¹ãƒˆã®ã¿
npm run test:unit

# çµ±åˆãƒ†ã‚¹ãƒˆã®ã¿
npm run test:integration
```

### ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™
- Statement Coverage: 80%ä»¥ä¸Š
- Branch Coverage: 75%ä»¥ä¸Š
- Function Coverage: 80%ä»¥ä¸Š
- Line Coverage: 80%ä»¥ä¸Š

## ğŸ“Œ æ³¨æ„äº‹é …

- ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã¯å„ãƒ†ã‚¹ãƒˆå¾Œã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
- æœ¬ç•ªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ã¯çµ¶å¯¾ã«æ¥ç¶šã—ãªã„
- ãƒ¢ãƒƒã‚¯ã¨ã‚¹ã‚¿ãƒ–ã‚’é©åˆ‡ã«ä½¿ã„åˆ†ã‘ã‚‹
- éåŒæœŸå‡¦ç†ã®ãƒ†ã‚¹ãƒˆã¯å¿…ãšawaitã™ã‚‹
- ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã‚‚å¿…ãšãƒ†ã‚¹ãƒˆã™ã‚‹

## ğŸ·ï¸ ãƒ©ãƒ™ãƒ«
`testing`, `jest`, `coverage`, `phase1`

## ğŸ“… ä½œæˆæ—¥
2025-09-08