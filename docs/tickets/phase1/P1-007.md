# チケット P1-007: 単体テスト作成

## 📋 概要
バックエンドAPIの単体テストとインテグレーションテストを作成し、コードカバレッジを測定する。

## 🎯 目標
- Jestテスト環境のセットアップ
- Repository層のテスト
- Service層のテスト
- Controller層のテスト
- APIインテグレーションテスト
- 80%以上のコードカバレッジ

## 📝 詳細説明

### 1. テスト環境セットアップ

```bash
# テスト関連パッケージのインストール
npm install -D jest @types/jest ts-jest
npm install -D supertest @types/supertest
npm install -D @faker-js/faker
npm install -D sqlite3  # テスト用インメモリDB
```

**jest.config.js:**
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/migrations/**',
    '!src/seeds/**',
    '!src/server.ts'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],
  globals: {
    'ts-jest': {
      tsconfig: {
        experimentalDecorators: true,
        emitDecoratorMetadata: true
      }
    }
  }
};
```

### 2. テスト用データベース設定

**src/test/setup.ts:**
```typescript
import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from '../entities/User';
import { Team } from '../entities/Team';
import { UserTeam } from '../entities/UserTeam';
import { Sport } from '../entities/Sport';
import { Location } from '../entities/Location';
import { Game } from '../entities/Game';
import { Match } from '../entities/Match';
import { MatchCommunication } from '../entities/MatchCommunication';

export const TestDataSource = new DataSource({
  type: 'sqlite',
  database: ':memory:',
  dropSchema: true,
  entities: [
    User, Team, UserTeam, Sport, 
    Location, Game, Match, MatchCommunication
  ],
  synchronize: true,
  logging: false
});

beforeAll(async () => {
  await TestDataSource.initialize();
});

afterAll(async () => {
  await TestDataSource.destroy();
});

beforeEach(async () => {
  // テーブルのクリア
  const entities = TestDataSource.entityMetadatas;
  for (const entity of entities) {
    const repository = TestDataSource.getRepository(entity.name);
    await repository.clear();
  }
});
```

### 3. テストユーティリティ

**src/test/factories/userFactory.ts:**
```typescript
import { faker } from '@faker-js/faker';
import { User } from '../../entities/User';
import { TestDataSource } from '../setup';

export const createUser = async (overrides?: Partial<User>): Promise<User> => {
  const userRepository = TestDataSource.getRepository(User);
  
  const user = userRepository.create({
    email: faker.internet.email(),
    password: 'password123',
    name: faker.person.fullName(),
    isActive: true,
    ...overrides
  });
  
  return userRepository.save(user);
};
```

**src/test/factories/teamFactory.ts:**
```typescript
import { faker } from '@faker-js/faker';
import { Team } from '../../entities/Team';
import { TestDataSource } from '../setup';

export const createTeam = async (overrides?: Partial<Team>): Promise<Team> => {
  const teamRepository = TestDataSource.getRepository(Team);
  
  const team = teamRepository.create({
    name: faker.company.name(),
    university: faker.company.name() + '大学',
    contactEmail: faker.internet.email(),
    description: faker.lorem.paragraph(),
    ...overrides
  });
  
  return teamRepository.save(team);
};
```

### 4. Repository層テスト

**src/repositories/__tests__/UserRepository.test.ts:**
```typescript
import { UserRepository } from '../UserRepository';
import { TestDataSource } from '../../test/setup';
import { createUser } from '../../test/factories/userFactory';

describe('UserRepository', () => {
  let userRepository: UserRepository;

  beforeEach(() => {
    userRepository = new UserRepository(TestDataSource);
  });

  describe('findByEmail', () => {
    it('should find user by email', async () => {
      const user = await createUser({ email: 'test@example.com' });
      
      const found = await userRepository.findByEmail('test@example.com');
      
      expect(found).toBeDefined();
      expect(found?.id).toBe(user.id);
      expect(found?.email).toBe('test@example.com');
    });

    it('should return null if user not found', async () => {
      const found = await userRepository.findByEmail('notfound@example.com');
      
      expect(found).toBeNull();
    });
  });

  describe('findWithTeams', () => {
    it('should find user with teams', async () => {
      const user = await createUser();
      // チーム関連のテストデータ作成
      
      const found = await userRepository.findWithTeams(user.id);
      
      expect(found).toBeDefined();
      expect(found?.userTeams).toBeDefined();
    });
  });
});
```

### 5. Service層テスト

**src/services/__tests__/UserService.test.ts:**
```typescript
import { UserService } from '../UserService';
import { UserRepository } from '../../repositories/UserRepository';
import { TestDataSource } from '../../test/setup';
import { createUser } from '../../test/factories/userFactory';
import { ConflictError, NotFoundError } from '../../errors/AppError';

describe('UserService', () => {
  let userService: UserService;
  let userRepository: UserRepository;

  beforeEach(() => {
    userRepository = new UserRepository(TestDataSource);
    userService = new UserService(userRepository);
  });

  describe('getAllUsers', () => {
    it('should return paginated users', async () => {
      // 15人のユーザーを作成
      for (let i = 0; i < 15; i++) {
        await createUser();
      }

      const result = await userService.getAllUsers(1, 10);

      expect(result.data).toHaveLength(10);
      expect(result.total).toBe(15);
      expect(result.page).toBe(1);
      expect(result.totalPages).toBe(2);
    });
  });

  describe('getUserById', () => {
    it('should return user by id', async () => {
      const user = await createUser();

      const found = await userService.getUserById(user.id);

      expect(found.id).toBe(user.id);
      expect(found.email).toBe(user.email);
    });

    it('should throw NotFoundError if user not found', async () => {
      await expect(userService.getUserById('invalid-id'))
        .rejects.toThrow(NotFoundError);
    });
  });

  describe('createUser', () => {
    it('should create new user', async () => {
      const userData = {
        email: 'new@example.com',
        password: 'password123',
        name: 'New User'
      };

      const user = await userService.createUser(userData);

      expect(user.email).toBe(userData.email);
      expect(user.name).toBe(userData.name);
      // パスワードはハッシュ化されている
      expect(user.password).not.toBe(userData.password);
    });

    it('should throw ConflictError if email exists', async () => {
      await createUser({ email: 'existing@example.com' });

      await expect(userService.createUser({
        email: 'existing@example.com',
        password: 'password',
        name: 'Test'
      })).rejects.toThrow(ConflictError);
    });
  });
});
```

### 6. Controller層テスト

**src/controllers/__tests__/UserController.test.ts:**
```typescript
import { Request, Response, NextFunction } from 'express';
import { UserController } from '../UserController';
import { UserService } from '../../services/UserService';

describe('UserController', () => {
  let userController: UserController;
  let userService: jest.Mocked<UserService>;
  let req: Partial<Request>;
  let res: Partial<Response>;
  let next: NextFunction;

  beforeEach(() => {
    userService = {
      getAllUsers: jest.fn(),
      getUserById: jest.fn(),
      createUser: jest.fn(),
      updateUser: jest.fn(),
      deleteUser: jest.fn()
    } as any;

    userController = new UserController(userService);

    req = {
      query: {},
      params: {},
      body: {}
    };

    res = {
      json: jest.fn().mockReturnThis(),
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis()
    };

    next = jest.fn();
  });

  describe('getAll', () => {
    it('should return users with pagination', async () => {
      const mockResult = {
        data: [],
        total: 0,
        page: 1,
        totalPages: 0
      };

      userService.getAllUsers.mockResolvedValue(mockResult);
      req.query = { page: '1', limit: '10' };

      await userController.getAll(req as Request, res as Response, next);

      expect(userService.getAllUsers).toHaveBeenCalledWith(1, 10);
      expect(res.json).toHaveBeenCalledWith(mockResult);
    });

    it('should handle errors', async () => {
      const error = new Error('Test error');
      userService.getAllUsers.mockRejectedValue(error);

      await userController.getAll(req as Request, res as Response, next);

      expect(next).toHaveBeenCalledWith(error);
    });
  });
});
```

### 7. APIインテグレーションテスト

**src/__tests__/api.integration.test.ts:**
```typescript
import request from 'supertest';
import app from '../app';
import { TestDataSource } from '../test/setup';
import { createUser } from '../test/factories/userFactory';
import jwt from 'jsonwebtoken';

describe('API Integration Tests', () => {
  let authToken: string;

  beforeAll(async () => {
    // テスト用トークン生成
    const user = await createUser();
    authToken = jwt.sign(
      { userId: user.id, email: user.email },
      process.env.JWT_SECRET || 'test-secret'
    );
  });

  describe('GET /api/users', () => {
    it('should require authentication', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect(401);

      expect(response.body.message).toBe('Authentication required');
    });

    it('should return users with valid token', async () => {
      await createUser();
      await createUser();

      const response = await request(app)
        .get('/api/users')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.data).toBeInstanceOf(Array);
      expect(response.body.data.length).toBeGreaterThan(0);
    });
  });

  describe('POST /api/users', () => {
    it('should create new user', async () => {
      const userData = {
        email: 'newuser@example.com',
        password: 'password123',
        name: 'New User'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);

      expect(response.body.email).toBe(userData.email);
      expect(response.body.name).toBe(userData.name);
      expect(response.body.password).toBeUndefined();
    });

    it('should validate request body', async () => {
      const invalidData = {
        email: 'invalid-email',
        password: '123',  // too short
        name: ''
      };

      const response = await request(app)
        .post('/api/users')
        .send(invalidData)
        .expect(400);

      expect(response.body.errors).toBeDefined();
    });
  });
});
```

### 8. package.jsonスクリプト更新

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:integration": "jest --testPathPattern=integration",
    "test:unit": "jest --testPathIgnorePatterns=integration"
  }
}
```

## ✅ 受け入れ条件

- [ ] Jest環境が正しく設定されている
- [ ] テスト用インメモリデータベースが動作する
- [ ] Repository層のテストが実装されている
- [ ] Service層のテストが実装されている
- [ ] Controller層のテストが実装されている
- [ ] APIインテグレーションテストが実装されている
- [ ] コードカバレッジが80%以上
- [ ] CI/CDでテストが自動実行される設定

## 🔧 技術要件

- Jest
- Supertest
- TypeScript対応
- SQLite（テスト用）
- Faker.js

## ⏱️ 見積もり時間
12時間

## 🔗 依存関係
- P1-005: CRUD API実装（完了必須）

## 🧪 テスト方針

### テスト実行コマンド
```bash
# 全テスト実行
npm test

# カバレッジ付きテスト
npm run test:coverage

# ウォッチモード
npm run test:watch

# 単体テストのみ
npm run test:unit

# 統合テストのみ
npm run test:integration
```

### カバレッジ目標
- Statement Coverage: 80%以上
- Branch Coverage: 75%以上
- Function Coverage: 80%以上
- Line Coverage: 80%以上

## 📌 注意事項

- テストデータは各テスト後にクリーンアップ
- 本番データベースには絶対に接続しない
- モックとスタブを適切に使い分ける
- 非同期処理のテストは必ずawaitする
- エラーケースも必ずテストする

## 🏷️ ラベル
`testing`, `jest`, `coverage`, `phase1`

## 📅 作成日
2025-09-08